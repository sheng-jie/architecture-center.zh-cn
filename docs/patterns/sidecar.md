---
title: "挎斗模式"
description: "将应用程序的组件部署到单独的进程或容器中，以提供隔离和封装。"
author: dragon119
ms.date: 06/23/2017
ms.openlocfilehash: ec168009aa99f412c3f1222a1c404ea4ea5cb669
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/14/2017
---
# <a name="sidecar-pattern"></a><span data-ttu-id="d425a-103">挎斗模式</span><span class="sxs-lookup"><span data-stu-id="d425a-103">Sidecar pattern</span></span>

<span data-ttu-id="d425a-104">将应用程序的组件部署到单独的进程或容器中，以提供隔离和封装。</span><span class="sxs-lookup"><span data-stu-id="d425a-104">Deploy components of an application into a separate process or container to provide isolation and encapsulation.</span></span> <span data-ttu-id="d425a-105">使用此模式还可以使用异构组件和技术来构建应用程序。</span><span class="sxs-lookup"><span data-stu-id="d425a-105">This pattern can also enable applications to be composed of heterogeneous components and technologies.</span></span>

<span data-ttu-id="d425a-106">此模式之所以称作“挎斗”(Sidecar)，是因为它类似于三轮摩托车上的挎斗。</span><span class="sxs-lookup"><span data-stu-id="d425a-106">This pattern is named *Sidecar* because it resembles a sidecar attached to a motorcycle.</span></span> <span data-ttu-id="d425a-107">在此模式中，挎斗附加到父应用程序，为应用程序提供支持性功能。</span><span class="sxs-lookup"><span data-stu-id="d425a-107">In the pattern, the sidecar is attached to a parent application and provides supporting features for the application.</span></span> <span data-ttu-id="d425a-108">此外，挎斗与父应用程序具有相同的生命周期：与父应用程序一起创建，一起停用。</span><span class="sxs-lookup"><span data-stu-id="d425a-108">The sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent.</span></span> <span data-ttu-id="d425a-109">挎斗模式有时也称为搭档模式，这是一种分解模式。</span><span class="sxs-lookup"><span data-stu-id="d425a-109">The sidecar pattern is sometimes referred to as the sidekick pattern and is a decomposition pattern.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="d425a-110">上下文和问题</span><span class="sxs-lookup"><span data-stu-id="d425a-110">Context and Problem</span></span>

<span data-ttu-id="d425a-111">应用程序和服务通常需要相关的功能，例如监视、日志记录、配置和网络服务。</span><span class="sxs-lookup"><span data-stu-id="d425a-111">Applications and services often require related functionality, such as monitoring, logging, configuration, and networking services.</span></span> <span data-ttu-id="d425a-112">可以作为单独的组件或服务实现这些外围任务。</span><span class="sxs-lookup"><span data-stu-id="d425a-112">These peripheral tasks can be implemented as separate components or services.</span></span> 

<span data-ttu-id="d425a-113">如果这些功能已紧密集成到应用程序中，则可以在运行应用程序的同一个进程中运行这些功能，从而有效利用共享资源。</span><span class="sxs-lookup"><span data-stu-id="d425a-113">If they are tightly integrated into the application, they can run in the same process as the application, making efficient use of shared resources.</span></span> <span data-ttu-id="d425a-114">但是，这也意味着无法对它们进行适当的隔离，其中一个组件发生故障就可能影响到其他组件甚至整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="d425a-114">However, this also means they are not well isolated, and an outage in one of these components can affect other components or the entire application.</span></span> <span data-ttu-id="d425a-115">此外，通常需要使用与父应用程序相同的语言来实现这些功能。</span><span class="sxs-lookup"><span data-stu-id="d425a-115">Also, they usually need to be implemented using the same language as the parent application.</span></span> <span data-ttu-id="d425a-116">因此，组件和应用程序之间保持着密切的相互依赖关系。</span><span class="sxs-lookup"><span data-stu-id="d425a-116">As a result, the component and the application have close interdependence on each other.</span></span>

<span data-ttu-id="d425a-117">如果应用程序已分解为服务，则可以使用不同的语言和技术构建每个服务。</span><span class="sxs-lookup"><span data-stu-id="d425a-117">If the application is decomposed into services, then each service can be built using different languages and technologies.</span></span> <span data-ttu-id="d425a-118">尽管这提高了灵活性，但同时也意味着，每个组件具有自身的依赖关系，需要使用特定于语言的库来访问底层平台，以及与父应用程序共享的所有资源。</span><span class="sxs-lookup"><span data-stu-id="d425a-118">While this gives more flexibility, it means that each component has its own dependencies and requires language-specific libraries to access the underlying platform and any resources shared with the parent application.</span></span> <span data-ttu-id="d425a-119">此外，将这些功能部署为单独的服务可能会增大应用程序的延迟。</span><span class="sxs-lookup"><span data-stu-id="d425a-119">In addition, deploying these features as separate services can add latency to the application.</span></span> <span data-ttu-id="d425a-120">管理这些特定于语言的接口的代码和依赖关系还可能会显著增大复杂性，尤其是托管、部署和管理的复杂性。</span><span class="sxs-lookup"><span data-stu-id="d425a-120">Managing the code and dependencies for these language-specific interfaces can also add considerable complexity, especially for hosting, deployment, and management.</span></span>

## <a name="solution"></a><span data-ttu-id="d425a-121">解决方案</span><span class="sxs-lookup"><span data-stu-id="d425a-121">Solution</span></span>

<span data-ttu-id="d425a-122">将一组内聚性的任务与主应用程序放在一起，不过，要将它们放在其自身的进程或容器内，以便为跨语言的平台服务提供同构接口。</span><span class="sxs-lookup"><span data-stu-id="d425a-122">Co-locate a cohesive set of tasks with the primary application, but place them inside their own process or container, providing a homogeneous interface for platform services across languages.</span></span> 

![](./_images/sidecar.png)

<span data-ttu-id="d425a-123">挎斗服务不一定要属于应用程序的一部分，而只是与应用程序相连接。</span><span class="sxs-lookup"><span data-stu-id="d425a-123">A sidecar service is not necessarily part of the application, but is connected to it.</span></span> <span data-ttu-id="d425a-124">不管它位于哪个位置，父应用程序都会跟随。</span><span class="sxs-lookup"><span data-stu-id="d425a-124">It goes wherever the parent application goes.</span></span> <span data-ttu-id="d425a-125">挎斗是连同主应用程序一起部署的支持性进程或服务。</span><span class="sxs-lookup"><span data-stu-id="d425a-125">Sidecars are supporting processes or services that are deployed with the primary application.</span></span> <span data-ttu-id="d425a-126">以三轮摩托车为例，挎斗附加在一辆三轮摩托车上，每辆三轮摩托车有自身的挎斗。</span><span class="sxs-lookup"><span data-stu-id="d425a-126">On a motorcycle, the sidecar is attached to one motorcycle, and each motorcycle can have its own sidecar.</span></span> <span data-ttu-id="d425a-127">同样，挎斗服务与其父应用程序具有相同的生命周期。</span><span class="sxs-lookup"><span data-stu-id="d425a-127">In the same way, a sidecar service shares the fate of its parent application.</span></span> <span data-ttu-id="d425a-128">对于应用程序的每个实例，都会部署一个挎斗实例，并连同应用程序实例一起托管该挎斗实例。</span><span class="sxs-lookup"><span data-stu-id="d425a-128">For each instance of the application, an instance of the sidecar is deployed and hosted alongside it.</span></span> 

<span data-ttu-id="d425a-129">使用挎斗模式的好处包括：</span><span class="sxs-lookup"><span data-stu-id="d425a-129">Advantages of using a sidecar pattern include:</span></span>

- <span data-ttu-id="d425a-130">在运行时环境和编程语言方面，挎斗与其主应用程序相互独立，因此，无需为每种语言开发一个挎斗。</span><span class="sxs-lookup"><span data-stu-id="d425a-130">A sidecar is independent from its primary application in terms of runtime environment and programming language, so you don't need to develop one sidecar per language.</span></span> 

- <span data-ttu-id="d425a-131">挎斗可以访问主应用程序所能访问的资源。</span><span class="sxs-lookup"><span data-stu-id="d425a-131">The sidecar can access the same resources as the primary application.</span></span> <span data-ttu-id="d425a-132">例如，一个挎斗可以监视该挎斗和主应用程序使用的系统资源。</span><span class="sxs-lookup"><span data-stu-id="d425a-132">For example, a sidecar can monitor system resources used by both the sidecar and the primary application.</span></span> 

- <span data-ttu-id="d425a-133">挎斗与主应用程序保持密切的距离，因此两者之间的通信不存在明显的延迟。</span><span class="sxs-lookup"><span data-stu-id="d425a-133">Because of its proximity to the primary application, there’s no significant latency when communicating between them.</span></span>

- <span data-ttu-id="d425a-134">即使是对于不提供扩展性机制的应用程序，也仍可以使用挎斗来扩展功能，只需在主应用程序所用的同一主机或子容器中，将挎斗附加为自身的进程即可。</span><span class="sxs-lookup"><span data-stu-id="d425a-134">Even for applications that don’t provide an extensibility mechanism, you can use a sidecar to extend functionality by attaching it as own process in the same host or sub-container as the primary application.</span></span>

<span data-ttu-id="d425a-135">挎斗模式通常与容器一起使用，因而称作挎斗容器或搭档容器。</span><span class="sxs-lookup"><span data-stu-id="d425a-135">The sidecar pattern is often used with containers and referred to as a sidecar container or sidekick container.</span></span> 

## <a name="issues-and-considerations"></a><span data-ttu-id="d425a-136">问题和注意事项</span><span class="sxs-lookup"><span data-stu-id="d425a-136">Issues and Considerations</span></span>

- <span data-ttu-id="d425a-137">请考虑部署服务、进程或容器时所用的部署和打包格式。</span><span class="sxs-lookup"><span data-stu-id="d425a-137">Consider the deployment and packaging format you will use to deploy services, processes, or containers.</span></span> <span data-ttu-id="d425a-138">容器特别适合用于挎斗模式。</span><span class="sxs-lookup"><span data-stu-id="d425a-138">Containers are particularly well suited to the sidecar pattern.</span></span>
- <span data-ttu-id="d425a-139">在设计挎斗服务时，请慎重决定进程间通信机制。</span><span class="sxs-lookup"><span data-stu-id="d425a-139">When designing a sidecar service, carefully decide on the interprocess communication mechanism.</span></span> <span data-ttu-id="d425a-140">除非达不到性能要求，否则请尽量使用不区分语言或框架的技术。</span><span class="sxs-lookup"><span data-stu-id="d425a-140">Try to use language- or framework-agnostic technologies unless performance requirements make that impractical.</span></span>
- <span data-ttu-id="d425a-141">在将功能放入挎斗之前，请考虑该功能是作为独立的服务还是更传统的守护程序运行更有利。</span><span class="sxs-lookup"><span data-stu-id="d425a-141">Before putting functionality into a sidecar, consider whether it would work better as a separate service or a more traditional daemon.</span></span>
- <span data-ttu-id="d425a-142">此外，请考虑是否能够以库的形式或使用传统扩展机制实现功能。</span><span class="sxs-lookup"><span data-stu-id="d425a-142">Also consider whether the functionality could be implemented as a library or using a traditional extension mechanism.</span></span> <span data-ttu-id="d425a-143">特定于语言的库可能提供更深度的集成和更少的网络开销。</span><span class="sxs-lookup"><span data-stu-id="d425a-143">Language-specific libraries may have a deeper level of integration and less network overhead.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="d425a-144">何时使用此模式</span><span class="sxs-lookup"><span data-stu-id="d425a-144">When to Use this Pattern</span></span>

<span data-ttu-id="d425a-145">在以下情况下使用此模式：</span><span class="sxs-lookup"><span data-stu-id="d425a-145">Use this pattern when:</span></span>

- <span data-ttu-id="d425a-146">主应用程序使用一组异类语言和框架。</span><span class="sxs-lookup"><span data-stu-id="d425a-146">Your primary application uses a heterogenous set of languages and frameworks.</span></span> <span data-ttu-id="d425a-147">使用不同框架以不同语言编写的应用程序可以使用挎斗服务中的某个组件。</span><span class="sxs-lookup"><span data-stu-id="d425a-147">A component located in a sidecar service can be consumed by applications written in different languages using different frameworks.</span></span>
- <span data-ttu-id="d425a-148">某个组件由远程团队或不同的组织拥有。</span><span class="sxs-lookup"><span data-stu-id="d425a-148">A component is owned by a remote team or a different organization.</span></span>
- <span data-ttu-id="d425a-149">某个组件或功能必须共置在应用程序所在的同一台主机上</span><span class="sxs-lookup"><span data-stu-id="d425a-149">A component or feature must be co-located on the same host as the application</span></span>
- <span data-ttu-id="d425a-150">希望某个服务与主应用程序具有相同的整体生命周期，但同时又能独立更新该服务。</span><span class="sxs-lookup"><span data-stu-id="d425a-150">You need a service that shares the overall lifecycle of your main application, but can be independently updated.</span></span>
- <span data-ttu-id="d425a-151">需要精细控制特定资源或组件的资源限制。</span><span class="sxs-lookup"><span data-stu-id="d425a-151">You need fine-grained control over resource limits for a particular resource or component.</span></span> <span data-ttu-id="d425a-152">例如，想要限制特定组件使用的内存量。</span><span class="sxs-lookup"><span data-stu-id="d425a-152">For example, you may want to restrict the amount of memory a specific component uses.</span></span> <span data-ttu-id="d425a-153">可将组件部署为挎斗，然后独立于主应用程序管理内存用量。</span><span class="sxs-lookup"><span data-stu-id="d425a-153">You can deploy the component as a sidecar and manage memory usage independently of the main application.</span></span>

<span data-ttu-id="d425a-154">此模式可能不适用于以下情况：</span><span class="sxs-lookup"><span data-stu-id="d425a-154">This pattern may not be suitable:</span></span>

- <span data-ttu-id="d425a-155">当进程间通信需要优化时。</span><span class="sxs-lookup"><span data-stu-id="d425a-155">When interprocess communication needs to be optimized.</span></span> <span data-ttu-id="d425a-156">父应用程序与挎斗服务之间的通信会产生一定的开销，执行调用时存在明显的延迟。</span><span class="sxs-lookup"><span data-stu-id="d425a-156">Communication between a parent application and sidecar services includes some overhead, notably latency in the calls.</span></span> <span data-ttu-id="d425a-157">频繁通信的接口可能无法接受这种弊端。</span><span class="sxs-lookup"><span data-stu-id="d425a-157">This may not be an acceptable trade-off for chatty interfaces.</span></span>
- <span data-ttu-id="d425a-158">在某些小型应用程序中，为每个实例部署挎斗服务所产生的资源开销会抵消隔离所带来的优势。</span><span class="sxs-lookup"><span data-stu-id="d425a-158">For small applications where the resource cost of deploying a sidecar service for each instance is not worth the advantage of isolation.</span></span>
- <span data-ttu-id="d425a-159">当服务需要以不同于或独立于主应用程序的方式缩放时。</span><span class="sxs-lookup"><span data-stu-id="d425a-159">When the service needs to scale differently than or independently from the main applications.</span></span> <span data-ttu-id="d425a-160">如果存在这种情况，将功能部署为独立的服务可能更好。</span><span class="sxs-lookup"><span data-stu-id="d425a-160">If so, it may be better to deploy the feature as a separate service.</span></span>

## <a name="example"></a><span data-ttu-id="d425a-161">示例</span><span class="sxs-lookup"><span data-stu-id="d425a-161">Example</span></span>

<span data-ttu-id="d425a-162">挎斗模式适用于许多方案。</span><span class="sxs-lookup"><span data-stu-id="d425a-162">The sidecar pattern is applicable to many scenarios.</span></span> <span data-ttu-id="d425a-163">一些常见示例：</span><span class="sxs-lookup"><span data-stu-id="d425a-163">Some common examples:</span></span>

- <span data-ttu-id="d425a-164">基础结构 API。</span><span class="sxs-lookup"><span data-stu-id="d425a-164">Infrastructure API.</span></span> <span data-ttu-id="d425a-165">基础结构开发团队创建了一个连同每个应用程序一起部署的服务，而不是特定于语言的客户端库，来访问基础结构。</span><span class="sxs-lookup"><span data-stu-id="d425a-165">The infrastructure development team creates a service that's deployed alongside each application, instead of a language-specific client library to access the infrastructure.</span></span> <span data-ttu-id="d425a-166">该服务作为挎斗加载，为基础结构服务（包括日志记录、环境数据、配置存储、发现、运行状况检查和监视程序服务）提供一个公用层。</span><span class="sxs-lookup"><span data-stu-id="d425a-166">The service is loaded as a sidecar and provides a common layer for infrastructure services, including logging, environment data, configuration store, discovery, health checks, and watchdog services.</span></span> <span data-ttu-id="d425a-167">挎斗还监视父应用程序的主机环境和进程（或容器），并将信息记录到集中式服务。</span><span class="sxs-lookup"><span data-stu-id="d425a-167">The sidecar also monitors the parent application's host environment and process (or container) and logs the information to a centralized service.</span></span>
- <span data-ttu-id="d425a-168">管理 NGINX/HAProxy。</span><span class="sxs-lookup"><span data-stu-id="d425a-168">Manage NGINX/HAProxy.</span></span> <span data-ttu-id="d425a-169">将 NGINX 与用于监视环境状态的挎斗服务一起部署，然后，在需要更改状态时更新 NGINX 配置文件并回收进程。</span><span class="sxs-lookup"><span data-stu-id="d425a-169">Deploy NGINX with a sidecar service that monitors environment state, then updates the NGINX configuration file and recycles the process when a change in state is needed.</span></span>
- <span data-ttu-id="d425a-170">代表挎斗。</span><span class="sxs-lookup"><span data-stu-id="d425a-170">Ambassador sidecar.</span></span> <span data-ttu-id="d425a-171">将[代表][ambassador]服务部署为挎斗。</span><span class="sxs-lookup"><span data-stu-id="d425a-171">Deploy an [ambassador][ambassador] service as a sidecar.</span></span> <span data-ttu-id="d425a-172">应用程序通过代表发出调用，后者可处理日志记录、路由、断路、和其他连接相关功能。</span><span class="sxs-lookup"><span data-stu-id="d425a-172">The application calls through the ambassador, which handles request logging, routing, circuit breaking, and other connectivity related features.</span></span>
- <span data-ttu-id="d425a-173">卸载代理。</span><span class="sxs-lookup"><span data-stu-id="d425a-173">Offload proxy.</span></span> <span data-ttu-id="d425a-174">将 NGINX 代理放在 node.js 服务实例的前面，以便为服务提供静态文件内容。</span><span class="sxs-lookup"><span data-stu-id="d425a-174">Place an NGINX proxy in front of a node.js service instance, to handle serving static file content for the service.</span></span>


## <a name="related-guidance"></a><span data-ttu-id="d425a-175">相关指南</span><span class="sxs-lookup"><span data-stu-id="d425a-175">Related guidance</span></span>

- <span data-ttu-id="d425a-176">[代表模式][ambassador]</span><span class="sxs-lookup"><span data-stu-id="d425a-176">[Ambassador pattern][ambassador]</span></span>


[ambassador]: ./ambassador.md

