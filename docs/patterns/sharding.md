---
title: "分片"
description: "将数据存储划分为一组水平分区或分片。"
keywords: "设计模式"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- data-management
- performance-scalability
ms.openlocfilehash: 328483e24c75137f07576104d50dc59d426b8ac4
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/14/2017
---
# <a name="sharding-pattern"></a><span data-ttu-id="86e33-104">分片模式</span><span class="sxs-lookup"><span data-stu-id="86e33-104">Sharding pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="86e33-105">将数据存储划分为一组水平分区或分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-105">Divide a data store into a set of horizontal partitions or shards.</span></span> <span data-ttu-id="86e33-106">这样可存储和访问大量数据时提高可伸缩性。</span><span class="sxs-lookup"><span data-stu-id="86e33-106">This can improve scalability when storing and accessing large volumes of data.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="86e33-107">上下文和问题</span><span class="sxs-lookup"><span data-stu-id="86e33-107">Context and problem</span></span>

<span data-ttu-id="86e33-108">由单个服务器托管的数据存储会受到以下限制：</span><span class="sxs-lookup"><span data-stu-id="86e33-108">A data store hosted by a single server might be subject to the following limitations:</span></span>

- <span data-ttu-id="86e33-109">**存储空间**。</span><span class="sxs-lookup"><span data-stu-id="86e33-109">**Storage space**.</span></span> <span data-ttu-id="86e33-110">用于大规模云应用程序的数据存储预期包含可随时间显着增加的大量数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-110">A data store for a large-scale cloud application is expected to contain a huge volume of data that could increase significantly over time.</span></span> <span data-ttu-id="86e33-111">服务器通常仅提供有限的磁盘存储，但可以将现有磁盘替换为存储控件更大的磁盘，或随着数据量的增长向计算机添加更多磁盘。</span><span class="sxs-lookup"><span data-stu-id="86e33-111">A server typically provides only a finite amount of disk storage, but you can replace existing disks with larger ones, or add further disks to a machine as data volumes grow.</span></span> <span data-ttu-id="86e33-112">但是，系统将最终达到上限，而在给定服务器上无法轻松地增加存储容量。</span><span class="sxs-lookup"><span data-stu-id="86e33-112">However, the system will eventually reach a limit where it isn't possible to easily increase the storage capacity on a given server.</span></span>

- <span data-ttu-id="86e33-113">**计算资源**。</span><span class="sxs-lookup"><span data-stu-id="86e33-113">**Computing resources**.</span></span> <span data-ttu-id="86e33-114">云应用程序时需要支持大量并发用户，其中每个用户均运行从数据存储检索信息的查询。</span><span class="sxs-lookup"><span data-stu-id="86e33-114">A cloud application is required to support a large number of concurrent users, each of which run queries that retrieve information from the data store.</span></span> <span data-ttu-id="86e33-115">使用单个服务器托管数据存储无法提供支持此负载所需的计算能力，从而因应用程序存储和检索数据超时而导致用户和频发故障的响应时间延长。可以添加内存或升级处理器，但在无法增加更多的任何计算资源时，表示系统已达到上限。</span><span class="sxs-lookup"><span data-stu-id="86e33-115">A single server hosting the data store might not be able to provide the necessary computing power to support this load, resulting in extended response times for users and frequent failures as applications attempting to store and retrieve data time out. It might be possible to add memory or upgrade processors, but the system will reach a limit when it isn't possible to increase the compute resources any further.</span></span>

- <span data-ttu-id="86e33-116">**网络带宽**。</span><span class="sxs-lookup"><span data-stu-id="86e33-116">**Network bandwidth**.</span></span> <span data-ttu-id="86e33-117">从根本上讲，在单个服务器上运行的数据存储的性能将受制于服务器可以接收请求和发送答复的速率。</span><span class="sxs-lookup"><span data-stu-id="86e33-117">Ultimately, the performance of a data store running on a single server is governed by the rate the server can receive requests and send replies.</span></span> <span data-ttu-id="86e33-118">网络流量可能会超过用于连接到服务器的网络容量，从而导致请求失败。</span><span class="sxs-lookup"><span data-stu-id="86e33-118">It's possible that the volume of network traffic might exceed the capacity of the network used to connect to the server, resulting in failed requests.</span></span>

- <span data-ttu-id="86e33-119">**地理位置**。</span><span class="sxs-lookup"><span data-stu-id="86e33-119">**Geography**.</span></span> <span data-ttu-id="86e33-120">由于法律，合规性或性能原因或出于降低数据访问延迟的目的，有必要将特定用户生成的数据与这些用户存储在同一区域中。</span><span class="sxs-lookup"><span data-stu-id="86e33-120">It might be necessary to store data generated by specific users in the same region as those users for legal, compliance, or performance reasons, or to reduce latency of data access.</span></span> <span data-ttu-id="86e33-121">如果用户分布在不同的国家/地区或区域，它可能无法在单个数据存储中存储应用程序的全部数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-121">If the users are dispersed across different countries or regions, it might not be possible to store the entire data for the application in a single data store.</span></span>

<span data-ttu-id="86e33-122">通过添加更多磁盘容量、处理能力、内存和网络连接进行垂直缩放可推迟其中某些限制的影响，但这只是一种临时解决方案。</span><span class="sxs-lookup"><span data-stu-id="86e33-122">Scaling vertically by adding more disk capacity, processing power, memory, and network connections can postpone the effects of some of these limitations, but it's likely to only be a temporary solution.</span></span> <span data-ttu-id="86e33-123">能够支持大量用户和大量数据的商业云应用程序必须能够接近无限缩放，因此垂直缩放并不一定是最佳解决方案。</span><span class="sxs-lookup"><span data-stu-id="86e33-123">A commercial cloud application capable of supporting large numbers of users and high volumes of data must be able to scale almost indefinitely, so vertical scaling isn't necessarily the best solution.</span></span>

## <a name="solution"></a><span data-ttu-id="86e33-124">解决方案</span><span class="sxs-lookup"><span data-stu-id="86e33-124">Solution</span></span>

<span data-ttu-id="86e33-125">将数据存储划分为水平分区或分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-125">Divide the data store into horizontal partitions or shards.</span></span> <span data-ttu-id="86e33-126">每个分片具有相同的架构，但保存其自己数据的不同子集。</span><span class="sxs-lookup"><span data-stu-id="86e33-126">Each shard has the same schema, but holds its own distinct subset of the data.</span></span> <span data-ttu-id="86e33-127">分片是自己权限内的数据存储（可以包含不同类型的许多实体的数据），在服务器上作为存储节点运行。</span><span class="sxs-lookup"><span data-stu-id="86e33-127">A shard is a data store in its own right (it can contain the data for many entities of different types), running on a server acting as a storage node.</span></span>

<span data-ttu-id="86e33-128">此模式具有以下优点：</span><span class="sxs-lookup"><span data-stu-id="86e33-128">This pattern has the following benefits:</span></span>

- <span data-ttu-id="86e33-129">通过添加在其他存储节点上运行的更多分片，可以向外扩展系统。</span><span class="sxs-lookup"><span data-stu-id="86e33-129">You can scale the system out by adding further shards running on additional storage nodes.</span></span>

- <span data-ttu-id="86e33-130">系统可以为每个存储节点使用现成的硬件，而不是专用且昂贵的计算机。</span><span class="sxs-lookup"><span data-stu-id="86e33-130">A system can use off-the-shelf hardware rather than specialized and expensive computers for each storage node.</span></span>

- <span data-ttu-id="86e33-131">通过在分片间平衡工作负荷可减少争用并提高性能。</span><span class="sxs-lookup"><span data-stu-id="86e33-131">You can reduce contention and improve performance by balancing the workload across shards.</span></span>

- <span data-ttu-id="86e33-132">在云中，分片可位于靠近将访问数据的用户的位置。</span><span class="sxs-lookup"><span data-stu-id="86e33-132">In the cloud, shards can be located physically close to the users that'll access the data.</span></span>

<span data-ttu-id="86e33-133">将数据存储分割成分片时，决定每个分片中应放置哪些数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-133">When dividing a data store up into shards, decide which data should be placed in each shard.</span></span> <span data-ttu-id="86e33-134">一个分片通常包含属于由数据的一个或多个属性决定的指定范围内的项。</span><span class="sxs-lookup"><span data-stu-id="86e33-134">A shard typically contains items that fall within a specified range determined by one or more attributes of the data.</span></span> <span data-ttu-id="86e33-135">这些属性构成分片键（有时称为分区键）。</span><span class="sxs-lookup"><span data-stu-id="86e33-135">These attributes form the shard key (sometimes referred to as the partition key).</span></span> <span data-ttu-id="86e33-136">分片键应为静态。</span><span class="sxs-lookup"><span data-stu-id="86e33-136">The shard key should be static.</span></span> <span data-ttu-id="86e33-137">它不应基于可能会更改的数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-137">It shouldn't be based on data that might change.</span></span>

<span data-ttu-id="86e33-138">分片以物理方式组织数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-138">Sharding physically organizes the data.</span></span> <span data-ttu-id="86e33-139">应用程序存储和检索数据时，分片逻辑将应用程序定向到相应分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-139">When an application stores and retrieves data, the sharding logic directs the application to the appropriate shard.</span></span> <span data-ttu-id="86e33-140">可以将此分片逻辑实现为应用程序中数据访问代码的一部分，或者如果它以透明方式支持分片，则可由数据存储系统实现它。</span><span class="sxs-lookup"><span data-stu-id="86e33-140">This sharding logic can be implemented as part of the data access code in the application, or it could be implemented by the data storage system if it transparently supports sharding.</span></span>

<span data-ttu-id="86e33-141">提取分片逻辑中数据的物理位置可提供哪些分片包含哪些数据的高级控制。</span><span class="sxs-lookup"><span data-stu-id="86e33-141">Abstracting the physical location of the data in the sharding logic provides a high level of control over which shards contain which data.</span></span> <span data-ttu-id="86e33-142">此外，如果分片中的数据稍后需要进行重新分配（例如，分片变得不平衡的情况），则还可以在无需重新处理应用程序的业务逻辑情况下，使数据在分片间进行迁移。</span><span class="sxs-lookup"><span data-stu-id="86e33-142">It also enables data to migrate between shards without reworking the business logic of an application if the data in the shards need to be redistributed later (for example, if the shards become unbalanced).</span></span> <span data-ttu-id="86e33-143">权衡是在确定每个数据项被检索时的位置所需的附加数据访问开销。</span><span class="sxs-lookup"><span data-stu-id="86e33-143">The tradeoff is the additional data access overhead required in determining the location of each data item as it's retrieved.</span></span>

<span data-ttu-id="86e33-144">若要确保获得最佳性能和可伸缩性，以适合于应用程序执行查询的类型方式拆分数据至关重要。</span><span class="sxs-lookup"><span data-stu-id="86e33-144">To ensure optimal performance and scalability, it's important to split the data in a way that's appropriate for the types of queries that the application performs.</span></span> <span data-ttu-id="86e33-145">在许多情况下，分片方案不可能完全匹配每个查询的要求。</span><span class="sxs-lookup"><span data-stu-id="86e33-145">In many cases, it's unlikely that the sharding scheme will exactly match the requirements of every query.</span></span> <span data-ttu-id="86e33-146">例如，在多租户系统中，应用程序可能需要使用租户 ID 检索租户数据，但还可能需要根据其他某些属性（例如租户的名称或位置）查找此数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-146">For example, in a multi-tenant system an application might need to retrieve tenant data using the tenant ID, but it might also need to look up this data based on some other attribute such as the tenant’s name or location.</span></span> <span data-ttu-id="86e33-147">若要处理这些情况，请使用支持最常执行的查询的分片键实现分片策略。</span><span class="sxs-lookup"><span data-stu-id="86e33-147">To handle these situations, implement a sharding strategy with a shard key that supports the most commonly performed queries.</span></span>

<span data-ttu-id="86e33-148">如果查询定期使用属性值结合检索数据，则可以通过将属性链接在一起定义复合分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-148">If queries regularly retrieve data using a combination of attribute values, you can likely define a composite shard key by linking attributes together.</span></span> <span data-ttu-id="86e33-149">或者，如使用模式（例如[索引表](index-table.md)）来提供针对基于分片键未覆盖属性的数据的快速查找。</span><span class="sxs-lookup"><span data-stu-id="86e33-149">Alternatively, use a pattern such as [Index Table](index-table.md) to provide fast lookup to data based on attributes that aren't covered by the shard key.</span></span>

## <a name="sharding-strategies"></a><span data-ttu-id="86e33-150">分片策略</span><span class="sxs-lookup"><span data-stu-id="86e33-150">Sharding strategies</span></span>

<span data-ttu-id="86e33-151">选择分片键并决定如何在分片之间分发数据时，通常使用三种策略。</span><span class="sxs-lookup"><span data-stu-id="86e33-151">Three strategies are commonly used when selecting the shard key and deciding how to distribute data across shards.</span></span> <span data-ttu-id="86e33-152">注意，分片和托管它们的服务器之间并不一定是一一对应关系&mdash;单个服务器可以托管多个分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-152">Note that there doesn't have to be a one-to-one correspondence between shards and the servers that host them&mdash;a single server can host multiple shards.</span></span> <span data-ttu-id="86e33-153">策略包括：</span><span class="sxs-lookup"><span data-stu-id="86e33-153">The strategies are:</span></span>

<span data-ttu-id="86e33-154">**查找策略**。</span><span class="sxs-lookup"><span data-stu-id="86e33-154">**The Lookup strategy**.</span></span> <span data-ttu-id="86e33-155">在此策略中，分片逻辑实现了一个映射，可使用分片键将对数据的请求路由到包含该数据的分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-155">In this strategy the sharding logic implements a map that routes a request for data to the shard that contains that data using the shard key.</span></span> <span data-ttu-id="86e33-156">在多租户应用程序中，将租户 ID 用作分片键，可将某个租户的所有数据一同存储在该分片中。</span><span class="sxs-lookup"><span data-stu-id="86e33-156">In a multi-tenant application all the data for a tenant might be stored together in a shard using the tenant ID as the shard key.</span></span> <span data-ttu-id="86e33-157">多个租户可以共享同一分片，但是单个租户的数据不会分布于多个分片中。</span><span class="sxs-lookup"><span data-stu-id="86e33-157">Multiple tenants might share the same shard, but the data for a single tenant won't be spread across multiple shards.</span></span> <span data-ttu-id="86e33-158">下图说明了基于租户 ID 的分片租户数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-158">The figure illustrates sharding tenant data based on tenant IDs.</span></span>

   ![图 1 - 基于租户 ID 的分片租户数据](./_images/sharding-tenant.png)


   <span data-ttu-id="86e33-160">分片键和物理存储之间的映射可基于每个分片键映射到物理分区的物理分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-160">The mapping between the shard key and the physical storage can be based on physical shards where each shard key maps to a physical partition.</span></span> <span data-ttu-id="86e33-161">或者，用于重新平衡分片的更灵活方法是虚拟分区，其中分片键映射到同一编号的虚拟分片，这样依次映射到更少的物理分区。</span><span class="sxs-lookup"><span data-stu-id="86e33-161">Alternatively, a more flexible technique for rebalancing shards is virtual partitioning, where shard keys map to the same number of virtual shards, which in turn map to fewer physical partitions.</span></span> <span data-ttu-id="86e33-162">在此方法中，应用程序使用引用虚拟分片的分片键查找数据，且以透明方式将虚拟分片映射到物理分区。</span><span class="sxs-lookup"><span data-stu-id="86e33-162">In this approach, an application locates data using a shard key that refers to a virtual shard, and the system transparently maps virtual shards to physical partitions.</span></span> <span data-ttu-id="86e33-163">无需修改应用程序代码，虚拟分片和物理分区之间的映射既可以更改为使用一组不同的分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-163">The mapping between a virtual shard and a physical partition can change without requiring the application code be modified to use a different set of shard keys.</span></span>

<span data-ttu-id="86e33-164">**范围策略**。</span><span class="sxs-lookup"><span data-stu-id="86e33-164">**The Range strategy**.</span></span> <span data-ttu-id="86e33-165">此策略将相关项目组合在同一分片中，并通过分片键对其进行排序 &mdash; 分片键是连续的。</span><span class="sxs-lookup"><span data-stu-id="86e33-165">This strategy groups related items together in the same shard, and orders them by shard key&mdash;the shard keys are sequential.</span></span> <span data-ttu-id="86e33-166">它对于经常使用范围查询检索项集的应用程序很有用（返回一组属于给定范围内的分片键的数据项的查询）。</span><span class="sxs-lookup"><span data-stu-id="86e33-166">It's useful for applications that frequently retrieve sets of items using range queries (queries that return a set of data items for a shard key that falls within a given range).</span></span> <span data-ttu-id="86e33-167">例如，如果应用程序经常需要查在给定月份中的所有订单，如果某月的全部订单以日期和时间顺序存储在同一分片中，则此数据可以更快地检索所有订单。</span><span class="sxs-lookup"><span data-stu-id="86e33-167">For example, if an application regularly needs to find all orders placed in a given month, this data can be retrieved more quickly if all orders for a month are stored in date and time order in the same shard.</span></span> <span data-ttu-id="86e33-168">如果每个订单存储在不同分片中，则需要将通过执行大量的点查询（返回单个数据项的查询）单独提取订单。</span><span class="sxs-lookup"><span data-stu-id="86e33-168">If each order was stored in a different shard, they'd have to be fetched individually by performing a large number of point queries (queries that return a single data item).</span></span> <span data-ttu-id="86e33-169">下一个图说明了分片中数据的存储顺序集（范围）。</span><span class="sxs-lookup"><span data-stu-id="86e33-169">The next figure illustrates storing sequential sets (ranges) of data in shard.</span></span>

   ![图 2 - 分片中数据的存储顺序集（范围）。](./_images/sharding-sequential-sets.png)

<span data-ttu-id="86e33-171">在此示例中，分片键是包含将订购月份作为最重要元素（后面是订单日期和时间）的复合键。</span><span class="sxs-lookup"><span data-stu-id="86e33-171">In this example, the shard key is a composite key containing the order month as the most significant element, followed by the order day and the time.</span></span> <span data-ttu-id="86e33-172">新建订单并将其添加到分片时，订单数据按自然顺序排序。</span><span class="sxs-lookup"><span data-stu-id="86e33-172">The data for orders is naturally sorted when new orders are created and added to a shard.</span></span> <span data-ttu-id="86e33-173">一些数据存储支持分片中的两部分分片键，包含可标识分片的分区键元素和唯一标识某个项的行键。</span><span class="sxs-lookup"><span data-stu-id="86e33-173">Some data stores support two-part shard keys containing a partition key element that identifies the shard and a row key that uniquely identifies an item in the shard.</span></span> <span data-ttu-id="86e33-174">数据通常会以行键顺序保留在分片中。</span><span class="sxs-lookup"><span data-stu-id="86e33-174">Data is usually held in row key order in the shard.</span></span> <span data-ttu-id="86e33-175">受范围查询支配并需要组合在一起的项可以使用具有同一分区键值的分片键，但行键值是唯一的。</span><span class="sxs-lookup"><span data-stu-id="86e33-175">Items that are subject to range queries and need to be grouped together can use a shard key that has the same value for the partition key but a unique value for the row key.</span></span>

<span data-ttu-id="86e33-176">**哈希策略**。</span><span class="sxs-lookup"><span data-stu-id="86e33-176">**The Hash strategy**.</span></span> <span data-ttu-id="86e33-177">此策略的目的是降低形成热点的可能性（接收不成比例的负载的分片）。</span><span class="sxs-lookup"><span data-stu-id="86e33-177">The purpose of this strategy is to reduce the chance of hotspots (shards that receive a disproportionate amount of load).</span></span> <span data-ttu-id="86e33-178">它以在每个分片的大小和每个分片将承载的平均负载之间取得平衡的方式在分片间分发数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-178">It distributes the data across the shards in a way that achieves a balance between the size of each shard and the average load that each shard will encounter.</span></span> <span data-ttu-id="86e33-179">分片逻辑基于数据的一个或多个属性的哈希来计算用于存储项目的分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-179">The sharding logic computes the shard to store an item in based on a hash of one or more attributes of the data.</span></span> <span data-ttu-id="86e33-180">所选的哈希函数应在分片间平均分发数据，可能将某些随机元素引入计算。</span><span class="sxs-lookup"><span data-stu-id="86e33-180">The chosen hashing function should distribute data evenly across the shards, possibly by introducing some random element into the computation.</span></span> <span data-ttu-id="86e33-181">下一个图说明了基于租户 ID 哈希的分片租户数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-181">The next figure illustrates sharding tenant data based on a hash of tenant IDs.</span></span>

   ![图 3 - 基于租户 ID 哈希的分片租户数据](./_images/sharding-data-hash.png)

<span data-ttu-id="86e33-183">要通过其他分片策略了解哈希策略的优势，请考虑按顺序注册新租户的多租户应用程序如何将租户分配到数据存储区中的分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-183">To understand the advantage of the Hash strategy over other sharding strategies, consider how a multi-tenant application that enrolls new tenants sequentially might assign the tenants to shards in the data store.</span></span> <span data-ttu-id="86e33-184">使用范围策略时，租户 1 到 n 的数据都将存储在分片 A 中，租户 n+1 到 m 的数据都存储在分片 B 上，依次类推。</span><span class="sxs-lookup"><span data-stu-id="86e33-184">When using the Range strategy, the data for tenants 1 to n will all be stored in shard A, the data for tenants n+1 to m will all be stored in shard B, and so on.</span></span> <span data-ttu-id="86e33-185">如果最近注册的租户也是最活跃的租户，则多数数据活动将发生在少数分片中，这会导致热点。</span><span class="sxs-lookup"><span data-stu-id="86e33-185">If the most recently registered tenants are also the most active, most data activity will occur in a small number of shards, which could cause hotspots.</span></span> <span data-ttu-id="86e33-186">与此相反，哈希策略根据租户 ID 的哈希将租户分配到分片中。</span><span class="sxs-lookup"><span data-stu-id="86e33-186">In contrast, the Hash strategy allocates tenants to shards based on a hash of their tenant ID.</span></span> <span data-ttu-id="86e33-187">这意味着连续的租户最有可能被分配到不同的分片，这会在分片间分发负载。</span><span class="sxs-lookup"><span data-stu-id="86e33-187">This means that sequential tenants are most likely to be allocated to different shards, which will distribute the load across them.</span></span> <span data-ttu-id="86e33-188">上图展示了为租户 55 和 56 分发负载的过程。</span><span class="sxs-lookup"><span data-stu-id="86e33-188">The previous figure shows this for tenants 55 and 56.</span></span>

<span data-ttu-id="86e33-189">者三个分片策略的优势和注意事项如下：</span><span class="sxs-lookup"><span data-stu-id="86e33-189">The three sharding strategies have the following advantages and considerations:</span></span>

- <span data-ttu-id="86e33-190">**查找**。</span><span class="sxs-lookup"><span data-stu-id="86e33-190">**Lookup**.</span></span> <span data-ttu-id="86e33-191">提供了分片配置和使用方式的更多控制权限。</span><span class="sxs-lookup"><span data-stu-id="86e33-191">This offers more control over the way that shards are configured and used.</span></span> <span data-ttu-id="86e33-192">重新平衡数据时，使用虚拟分片可减少影响，因为可添加新的物理分区来平摊工作负荷。</span><span class="sxs-lookup"><span data-stu-id="86e33-192">Using virtual shards reduces the impact when rebalancing data because new physical partitions can be added to even out the workload.</span></span> <span data-ttu-id="86e33-193">无需影响使用分片键来存储和检索数据的应用程序代码，即可修改虚拟分片和实现分片的物理分区之间的映射。</span><span class="sxs-lookup"><span data-stu-id="86e33-193">The mapping between a virtual shard and the physical partitions that implement the shard can be modified without affecting application code that uses a shard key to store and retrieve data.</span></span> <span data-ttu-id="86e33-194">查找分片位置会产生额外开销。</span><span class="sxs-lookup"><span data-stu-id="86e33-194">Looking up shard locations can impose an additional overhead.</span></span>

- <span data-ttu-id="86e33-195">**范围**。</span><span class="sxs-lookup"><span data-stu-id="86e33-195">**Range**.</span></span> <span data-ttu-id="86e33-196">该策略很容易实现，并且适用于范围查询，因为它们通常可以在单个操作中从单个分片中提取多个数据项。</span><span class="sxs-lookup"><span data-stu-id="86e33-196">This is easy to implement and works well with range queries because they can often fetch multiple data items from a single shard in a single operation.</span></span> <span data-ttu-id="86e33-197">此策略提供更简单的数据管理。</span><span class="sxs-lookup"><span data-stu-id="86e33-197">This strategy offers easier data management.</span></span> <span data-ttu-id="86e33-198">例如，如果同一区域中的用户位于同一分片中，则可以基于本地负载和需求模式在每个时区中调度更新。</span><span class="sxs-lookup"><span data-stu-id="86e33-198">For example, if users in the same region are in the same shard, updates can be scheduled in each time zone based on the local load and demand pattern.</span></span> <span data-ttu-id="86e33-199">但此策略不提供分片间的最佳平衡。</span><span class="sxs-lookup"><span data-stu-id="86e33-199">However, this strategy doesn't provide optimal balancing between shards.</span></span> <span data-ttu-id="86e33-200">如果大多数活动适用于毗邻的分片键，则重新平衡分片很困难并且可能无法解析负载不均的问题。</span><span class="sxs-lookup"><span data-stu-id="86e33-200">Rebalancing shards is difficult and might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys.</span></span>

- <span data-ttu-id="86e33-201">**哈希**。</span><span class="sxs-lookup"><span data-stu-id="86e33-201">**Hash**.</span></span> <span data-ttu-id="86e33-202">此策略提供了可更平均的分配数据和负载的方式。</span><span class="sxs-lookup"><span data-stu-id="86e33-202">This strategy offers a better chance of more even data and load distribution.</span></span> <span data-ttu-id="86e33-203">请求路由可直接通过使用哈希函数来完成。</span><span class="sxs-lookup"><span data-stu-id="86e33-203">Request routing can be accomplished directly by using the hash function.</span></span> <span data-ttu-id="86e33-204">无需维护映射。</span><span class="sxs-lookup"><span data-stu-id="86e33-204">There's no need to maintain a map.</span></span> <span data-ttu-id="86e33-205">注意：计算哈希值可能会产生额外开销。</span><span class="sxs-lookup"><span data-stu-id="86e33-205">Note that computing the hash might impose an additional overhead.</span></span> <span data-ttu-id="86e33-206">此外，重新平衡分片会很困难。</span><span class="sxs-lookup"><span data-stu-id="86e33-206">Also, rebalancing shards is difficult.</span></span>

<span data-ttu-id="86e33-207">最常见的分片系统会实现上述方法之一，但是你还应考虑应用程序的业务要求及其数据使用模式。</span><span class="sxs-lookup"><span data-stu-id="86e33-207">Most common sharding systems implement one of the approaches described above, but you should also consider the business requirements of your applications and their patterns of data usage.</span></span> <span data-ttu-id="86e33-208">例如，在多租户应用程序中：</span><span class="sxs-lookup"><span data-stu-id="86e33-208">For example, in a multi-tenant application:</span></span>

- <span data-ttu-id="86e33-209">可以根据工作负载分片数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-209">You can shard data based on workload.</span></span> <span data-ttu-id="86e33-210">可以在单独的分片中分离高度易失性租户的数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-210">You could segregate the data for highly volatile tenants in separate shards.</span></span> <span data-ttu-id="86e33-211">因此，可能会提高其他租户的数据访问速度。</span><span class="sxs-lookup"><span data-stu-id="86e33-211">The speed of data access for other tenants might be improved as a result.</span></span>

- <span data-ttu-id="86e33-212">可以根据租户位置分片数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-212">You can shard data based on the location of tenants.</span></span> <span data-ttu-id="86e33-213">可以脱机获取特定地理区域中的租户的数据，以便在该区域的非高峰时段进行备份和维护，而其他区域中的租户的数据保持在线并可在其工作时间访问。</span><span class="sxs-lookup"><span data-stu-id="86e33-213">You can take the data for tenants in a specific geographic region offline for backup and maintenance during off-peak hours in that region, while the data for tenants in other regions remains online and accessible during their business hours.</span></span>

- <span data-ttu-id="86e33-214">为高值租户分配他们自己的私有、高性能、负载较轻的分片，而低值租户可能分享排列更密集的、繁忙的分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-214">High-value tenants could be assigned their own private, high performing, lightly loaded shards, whereas lower-value tenants might be expected to share more densely-packed, busy shards.</span></span>

- <span data-ttu-id="86e33-215">需要高度数据隔离和隐私的租户的数据可以存储在完全独立的服务器上。</span><span class="sxs-lookup"><span data-stu-id="86e33-215">The data for tenants that need a high degree of data isolation and privacy can be stored on a completely separate server.</span></span>

## <a name="scaling-and-data-movement-operations"></a><span data-ttu-id="86e33-216">缩放和数据移动操作</span><span class="sxs-lookup"><span data-stu-id="86e33-216">Scaling and data movement operations</span></span>

<span data-ttu-id="86e33-217">每个分片策略表示用于管理缩小、扩大、数据移动和维护状态的不同能力和复杂性水平。</span><span class="sxs-lookup"><span data-stu-id="86e33-217">Each of the sharding strategies implies different capabilities and levels of complexity for managing scale in, scale out, data movement, and maintaining state.</span></span>

<span data-ttu-id="86e33-218">查找策略允许在联机或脱机时，在用户级别执行缩放和数据移动操作。</span><span class="sxs-lookup"><span data-stu-id="86e33-218">The Lookup strategy permits scaling and data movement operations to be carried out at the user level, either online or offline.</span></span> <span data-ttu-id="86e33-219">该技术可以暂停某些或所有用户活动（可能在非高峰时段）、将数据移动到新的虚拟分区或物理分片、更改映射、使保存此数据的任何缓存无效或重新刷新这些缓存，然后允许用户活动恢复。</span><span class="sxs-lookup"><span data-stu-id="86e33-219">The technique is to suspend some or all user activity (perhaps during off-peak periods), move the data to the new virtual partition or physical shard, change the mappings, invalidate or refresh any caches that hold this data, and then allow user activity to resume.</span></span> <span data-ttu-id="86e33-220">通常可以集中管理此类型的操作。</span><span class="sxs-lookup"><span data-stu-id="86e33-220">Often this type of operation can be centrally managed.</span></span> <span data-ttu-id="86e33-221">查找策略要求高度可缓存及可友好复制的状态。</span><span class="sxs-lookup"><span data-stu-id="86e33-221">The Lookup strategy requires state to be highly cacheable and replica friendly.</span></span>

<span data-ttu-id="86e33-222">范围策略对缩放和数据移动操作施加了一些限制，这些限制通常必须在部分或全部数据存储脱机时执行，因为数据必须在分片间进行拆分和合并。</span><span class="sxs-lookup"><span data-stu-id="86e33-222">The Range strategy imposes some limitations on scaling and data movement operations, which must typically be carried out when a part or all of the data store is offline because the data must be split and merged across the shards.</span></span> <span data-ttu-id="86e33-223">如果大多数活动是针对相同范围内的相邻分片键或数据标识符，则将数据移动到重新平衡分片可能无法解决负载不均的问题。</span><span class="sxs-lookup"><span data-stu-id="86e33-223">Moving the data to rebalance shards might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys or data identifiers that are within the same range.</span></span> <span data-ttu-id="86e33-224">范围策略还可能需要维护一些状态，以便将范围映射到物理分区。</span><span class="sxs-lookup"><span data-stu-id="86e33-224">The Range strategy might also require some state to be maintained in order to map ranges to the physical partitions.</span></span>

<span data-ttu-id="86e33-225">哈希策略使缩放和数据移动操作更复杂，因为分区键是分片键或数据标识符的哈希。</span><span class="sxs-lookup"><span data-stu-id="86e33-225">The Hash strategy makes scaling and data movement operations more complex because the partition keys are hashes of the shard keys or data identifiers.</span></span> <span data-ttu-id="86e33-226">必须从哈希函数或经修改以提供正确映射的函数中确定每个分片的新位置。</span><span class="sxs-lookup"><span data-stu-id="86e33-226">The new location of each shard must be determined from the hash function, or the function modified to provide the correct mappings.</span></span> <span data-ttu-id="86e33-227">但是，哈希策略不需要状态维护。</span><span class="sxs-lookup"><span data-stu-id="86e33-227">However, the Hash strategy doesn't require maintenance of state.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="86e33-228">问题和注意事项</span><span class="sxs-lookup"><span data-stu-id="86e33-228">Issues and considerations</span></span>

<span data-ttu-id="86e33-229">在决定如何实现此模式时，请考虑以下几点：</span><span class="sxs-lookup"><span data-stu-id="86e33-229">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="86e33-230">分片是其他形式的分区的补充（如垂直分区和功能分区）。</span><span class="sxs-lookup"><span data-stu-id="86e33-230">Sharding is complementary to other forms of partitioning, such as vertical partitioning and functional partitioning.</span></span> <span data-ttu-id="86e33-231">例如，单个分片可包含已垂直分区的实体，且功能分区可实现为多个分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-231">For example, a single shard can contain entities that have been partitioned vertically, and a functional partition can be implemented as multiple shards.</span></span> <span data-ttu-id="86e33-232">有关分区的详细信息，请参阅 [数据分区指导](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="86e33-232">For more information about partitioning, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="86e33-233">保持分片平衡，这样它们就可处理类似的 I/O 卷。</span><span class="sxs-lookup"><span data-stu-id="86e33-233">Keep shards balanced so they all handle a similar volume of I/O.</span></span> <span data-ttu-id="86e33-234">随着插入和删除数据，需要定期重新平衡分片，以保证均匀分布并降低形成成热点的可能性。</span><span class="sxs-lookup"><span data-stu-id="86e33-234">As data is inserted and deleted, it's necessary to periodically rebalance the shards to guarantee an even distribution and to reduce the chance of hotspots.</span></span> <span data-ttu-id="86e33-235">重新平衡是一项昂贵的操作。</span><span class="sxs-lookup"><span data-stu-id="86e33-235">Rebalancing can be an expensive operation.</span></span> <span data-ttu-id="86e33-236">若要减少重新平衡的需要，请通过确保每个分片包含足够的可用空间来处理预期的卷变化来规划存储增长。</span><span class="sxs-lookup"><span data-stu-id="86e33-236">To reduce the necessity of rebalancing, plan for growth by ensuring that each shard contains sufficient free space to handle the expected volume of changes.</span></span> <span data-ttu-id="86e33-237">还应开发可以在必要时用于快速重新平衡分片的策略和脚本。</span><span class="sxs-lookup"><span data-stu-id="86e33-237">You should also develop strategies and scripts you can use to quickly rebalance shards if this becomes necessary.</span></span>

- <span data-ttu-id="86e33-238">将稳定数据用于分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-238">Use stable data for the shard key.</span></span> <span data-ttu-id="86e33-239">如果分片键发生更改，则相应的数据项目可能需要在分片间移动，从而增加更新操作所执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="86e33-239">If the shard key changes, the corresponding data item might have to move between shards, increasing the amount of work performed by update operations.</span></span> <span data-ttu-id="86e33-240">为此，避免使分片键基于潜在不稳定信息。</span><span class="sxs-lookup"><span data-stu-id="86e33-240">For this reason, avoid basing the shard key on potentially volatile information.</span></span> <span data-ttu-id="86e33-241">相反，查找不变的或自然形成键的属性。</span><span class="sxs-lookup"><span data-stu-id="86e33-241">Instead, look for attributes that are invariant or that naturally form a key.</span></span>

- <span data-ttu-id="86e33-242">确保分片键是唯一的。</span><span class="sxs-lookup"><span data-stu-id="86e33-242">Ensure that shard keys are unique.</span></span> <span data-ttu-id="86e33-243">例如，避免使用自动递增字段作为分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-243">For example, avoid using autoincrementing fields as the shard key.</span></span> <span data-ttu-id="86e33-244">在某些系统中，自动递增字段无法跨分片进行协调，从而可能会导致不同分片中的项具有相同分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-244">Is some systems, autoincremented fields can't be coordinated across shards, possibly resulting in items in different shards having the same shard key.</span></span>

    >  <span data-ttu-id="86e33-245">不是分片键的其他字段中的自动递增值也可能会导致问题。</span><span class="sxs-lookup"><span data-stu-id="86e33-245">Autoincremented values in other fields that are not shard keys can also cause problems.</span></span> <span data-ttu-id="86e33-246">例如，如果使用自动递增字段生成唯一 ID，则位于不同分片中的两个不同项可能会分配有相同 ID。</span><span class="sxs-lookup"><span data-stu-id="86e33-246">For example, if you use autoincremented fields to generate unique IDs, then two different items located in different shards might be assigned the same ID.</span></span>

- <span data-ttu-id="86e33-247">可能无法设计出符合针对数据的每个可能查询要求的分片键。</span><span class="sxs-lookup"><span data-stu-id="86e33-247">It might not be possible to design a shard key that matches the requirements of every possible query against the data.</span></span> <span data-ttu-id="86e33-248">对数据进行分片以支持执行最频繁的查询，并且在必要时创建辅助索引表，以支持使用基于不属于分片键一部分的属性的条件检索数据的查询。</span><span class="sxs-lookup"><span data-stu-id="86e33-248">Shard the data to support the most frequently performed queries, and if necessary create secondary index tables to support queries that retrieve data using criteria based on attributes that aren't part of the shard key.</span></span> <span data-ttu-id="86e33-249">有关详细信息，请参阅[索引表模式](index-table.md)。</span><span class="sxs-lookup"><span data-stu-id="86e33-249">For more information, see the [Index Table pattern](index-table.md).</span></span>

- <span data-ttu-id="86e33-250">仅访问单个分片的查询比从多个分片检索数据的查询更加高效，因此实现的分片系统应避免导致应用程序执行大量对保存在不同分片中的数据进行联接的查询。</span><span class="sxs-lookup"><span data-stu-id="86e33-250">Queries that access only a single shard are more efficient than those that retrieve data from multiple shards, so avoid implementing a sharding system that results in applications performing large numbers of queries that join data held in different shards.</span></span> <span data-ttu-id="86e33-251">请记住，单个分片可以包含多种类型的实体的数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-251">Remember that a single shard can contain the data for multiple types of entities.</span></span> <span data-ttu-id="86e33-252">请考虑使非规范化数据以便将经常查询的相关实体（如客户和他们已下订单的详细信息）一起保留在相同分区中，从而减少应用程序执行的单独读取数。</span><span class="sxs-lookup"><span data-stu-id="86e33-252">Consider denormalizing your data to keep related entities that are commonly queried together (such as the details of customers and the orders that they have placed) in the same shard to reduce the number of separate reads that an application performs.</span></span>

    >  <span data-ttu-id="86e33-253">如果一个分片中的实体引用另一个分片中存储的实体，请将第二个实体的分片键包含在第一个实体的架构中。</span><span class="sxs-lookup"><span data-stu-id="86e33-253">If an entity in one shard references an entity stored in another shard, include the shard key for the second entity as part of the schema for the first entity.</span></span> <span data-ttu-id="86e33-254">这可以帮助提高跨分片引用相关数据的查询的性能。</span><span class="sxs-lookup"><span data-stu-id="86e33-254">This can help to improve the performance of queries that reference related data across shards.</span></span>

- <span data-ttu-id="86e33-255">如果应用程序必须执行从多个分片检索数据的查询，则可以使用并行任务提取此数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-255">If an application must perform queries that retrieve data from multiple shards, it might be possible to fetch this data by using parallel tasks.</span></span> <span data-ttu-id="86e33-256">示例包括扇出查询，其中来自多个分片的数据会并行进行检索，然后聚合到单个结果中。</span><span class="sxs-lookup"><span data-stu-id="86e33-256">Examples include fan-out queries, where data from multiple shards is retrieved in parallel and then aggregated into a single result.</span></span> <span data-ttu-id="86e33-257">但是，此方法不可避免地会在一定程度上增加解决方案数据访问逻辑的复杂性。</span><span class="sxs-lookup"><span data-stu-id="86e33-257">However, this approach inevitably adds some complexity to the data access logic of a solution.</span></span>

- <span data-ttu-id="86e33-258">对于许多应用程序，创建更多小分片可能比使用少量大分片更加高效，因为它们可以为负载均衡提供更多机会。</span><span class="sxs-lookup"><span data-stu-id="86e33-258">For many applications, creating a larger number of small shards can be more efficient than having a small number of large shards because they can offer increased opportunities for load balancing.</span></span> <span data-ttu-id="86e33-259">如果预计需要将分片从一个物理位置迁移到另一个位置，则也可能十分有用。</span><span class="sxs-lookup"><span data-stu-id="86e33-259">This can also be useful if you anticipate the need to migrate shards from one physical location to another.</span></span> <span data-ttu-id="86e33-260">移动小分片比移动大分片更快。</span><span class="sxs-lookup"><span data-stu-id="86e33-260">Moving a small shard is quicker than moving a large one.</span></span>

- <span data-ttu-id="86e33-261">确保每个分片存储节点的可用资源充足，在数据大小和吞吐量方面可以应对可伸缩性要求。</span><span class="sxs-lookup"><span data-stu-id="86e33-261">Make sure the resources available to each shard storage node are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="86e33-262">有关详细信息，请参阅[数据分区指南](https://msdn.microsoft.com/library/dn589795.aspx)中的“针对可伸缩性设计分区”部分。</span><span class="sxs-lookup"><span data-stu-id="86e33-262">For more information, see the section “Designing Partitions for Scalability” in the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="86e33-263">请考虑将引用数据复制到所有分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-263">Consider replicating reference data to all shards.</span></span> <span data-ttu-id="86e33-264">如果从分片检索数据的操作还在相同查询中引用静态或缓慢移动的数据，请将此数据添加到分片。</span><span class="sxs-lookup"><span data-stu-id="86e33-264">If an operation that retrieves data from a shard also references static or slow-moving data as part of the same query, add this data to the shard.</span></span> <span data-ttu-id="86e33-265">应用程序随后可以方便地提取所有数据进行查询，而不必对单独的数据存储进行额外往返。</span><span class="sxs-lookup"><span data-stu-id="86e33-265">The application can then fetch all of the data for the query easily, without having to make an additional round trip to a separate data store.</span></span>

    >  <span data-ttu-id="86e33-266">如果保存在多个分片中的引用数据更改，则系统必须在所有分片之间同步这些更改。</span><span class="sxs-lookup"><span data-stu-id="86e33-266">If reference data held in multiple shards changes, the system must synchronize these changes across all shards.</span></span> <span data-ttu-id="86e33-267">进行此同步时，系统可能会遇到一定程度的不一致。</span><span class="sxs-lookup"><span data-stu-id="86e33-267">The system can experience a degree of inconsistency while this synchronization occurs.</span></span> <span data-ttu-id="86e33-268">如果执行此操作，应将应用程序设计为能够处理它。</span><span class="sxs-lookup"><span data-stu-id="86e33-268">If you do this, you should design your applications to be able to handle it.</span></span>

- <span data-ttu-id="86e33-269">可能难以在分片之间保持引用完整性和一致性，因此应尽量减少会影响多个分片中的数据的操作。</span><span class="sxs-lookup"><span data-stu-id="86e33-269">It can be difficult to maintain referential integrity and consistency between shards, so you should minimize operations that affect data in multiple shards.</span></span> <span data-ttu-id="86e33-270">如果应用程序必须跨分片修改数据，请评估是否实际需要完全数据一致性。</span><span class="sxs-lookup"><span data-stu-id="86e33-270">If an application must modify data across shards, evaluate whether complete data consistency is actually required.</span></span> <span data-ttu-id="86e33-271">云中的常见方法是实施最终一致性。</span><span class="sxs-lookup"><span data-stu-id="86e33-271">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="86e33-272">每个分区中的数据会单独进行更新，应用程序逻辑必须负责确保所有更新成功完成，以及在最终一致的操作运行时处理可能由数据查询引起的不一致性。</span><span class="sxs-lookup"><span data-stu-id="86e33-272">The data in each partition is updated separately, and the application logic must take responsibility for ensuring that the updates all complete successfully, as well as handling the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="86e33-273">有关实施最终一致性的详细信息，请参阅[数据一致性入门](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="86e33-273">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

- <span data-ttu-id="86e33-274">配置和管理大量分片可能是一个挑战。</span><span class="sxs-lookup"><span data-stu-id="86e33-274">Configuring and managing a large number of shards can be a challenge.</span></span> <span data-ttu-id="86e33-275">诸如监视、备份、检查一致性以及日志记录或审核这类任务必须在可能位于多个位置的多个分片和服务器上完成。</span><span class="sxs-lookup"><span data-stu-id="86e33-275">Tasks such as monitoring, backing up, checking for consistency, and logging or auditing must be accomplished on multiple shards and servers, possibly held in multiple locations.</span></span> <span data-ttu-id="86e33-276">这些任务可能使用脚本或其他自动化解决方案来实现，但是这可能无法完全消除额外的管理要求。</span><span class="sxs-lookup"><span data-stu-id="86e33-276">These tasks are likely to be implemented using scripts or other automation solutions, but that might not completely eliminate the additional administrative requirements.</span></span>

- <span data-ttu-id="86e33-277">可以将分片放置在使它们所包含的数据接近于使用它的应用程序实例的地理位置处。</span><span class="sxs-lookup"><span data-stu-id="86e33-277">Shards can be geolocated so that the data that they contain is close to the instances of an application that use it.</span></span> <span data-ttu-id="86e33-278">此方法可以显著提高性能，但是需要额外考虑必须访问不同位置的多个分片的任务。</span><span class="sxs-lookup"><span data-stu-id="86e33-278">This approach can considerably improve performance, but requires additional consideration for tasks that must access multiple shards in different locations.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="86e33-279">何时使用此模式</span><span class="sxs-lookup"><span data-stu-id="86e33-279">When to use this pattern</span></span>

<span data-ttu-id="86e33-280">当数据存储可能需要扩展超过单个存储节点可用的资源，或通过减少数据存储中的争用来提高性能时，可使用此模式。</span><span class="sxs-lookup"><span data-stu-id="86e33-280">Use this pattern when a data store is likely to need to scale beyond the resources available to a single storage node, or to improve performance by reducing contention in a data store.</span></span>

>  <span data-ttu-id="86e33-281">分片的主要重点是提高系统的性能和可伸缩性，不过作为副产品，它还可以由于将数据划分到单独分区中的方式而提高可用性。</span><span class="sxs-lookup"><span data-stu-id="86e33-281">The primary focus of sharding is to improve the performance and scalability of a system, but as a by-product it can also improve availability due to how the data is divided into separate partitions.</span></span> <span data-ttu-id="86e33-282">一个分区中的故障不一定会阻止应用程序访问其他分区中保存的数据，操作员可以执行一个或多个分区的维护或恢复，而不会使应用程序的整个数据不可访问。</span><span class="sxs-lookup"><span data-stu-id="86e33-282">A failure in one partition doesn't necessarily prevent an application from accessing data held in other partitions, and an operator can perform maintenance or recovery of one or more partitions without making the entire data for an application inaccessible.</span></span> <span data-ttu-id="86e33-283">有关详细信息，请参阅[数据分区指南](https://msdn.microsoft.com/library/dn589795.aspx)。</span><span class="sxs-lookup"><span data-stu-id="86e33-283">For more information, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

## <a name="example"></a><span data-ttu-id="86e33-284">示例</span><span class="sxs-lookup"><span data-stu-id="86e33-284">Example</span></span>

<span data-ttu-id="86e33-285">以下 C# 示例使用一组充当分片的 SQL Server 数据库。</span><span class="sxs-lookup"><span data-stu-id="86e33-285">The following example in C# uses a set of SQL Server databases acting as shards.</span></span> <span data-ttu-id="86e33-286">每个数据库都保存应用程序使用的数据的子集。</span><span class="sxs-lookup"><span data-stu-id="86e33-286">Each database holds a subset of the data used by an application.</span></span> <span data-ttu-id="86e33-287">应用程序使用自己的分片逻辑检索跨分片分布的数据（这是扇出查询的示例）。</span><span class="sxs-lookup"><span data-stu-id="86e33-287">The application retrieves data that's distributed across the shards using its own sharding logic (this is an example of a fan-out query).</span></span> <span data-ttu-id="86e33-288">一个名为 `GetShards` 的方法会返回位于每个分片中的数据的详细信息。</span><span class="sxs-lookup"><span data-stu-id="86e33-288">The details of the data that's located in each shard is returned by a method called `GetShards`.</span></span> <span data-ttu-id="86e33-289">此方法返回 `ShardInformation` 对象的可枚举列表，其中 `ShardInformation` 类型包含每个分片的标识符和应用程序应用于连接到分片的 SQL Server 连接字符串（连接字符串未显示在代码示例中）。</span><span class="sxs-lookup"><span data-stu-id="86e33-289">This method returns an enumerable list of `ShardInformation` objects, where the `ShardInformation` type contains an identifier for each shard and the SQL Server connection string that an application should use to connect to the shard (the connection strings aren't shown in the code example).</span></span>

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

<span data-ttu-id="86e33-290">以下代码演示应用程序如何使用 `ShardInformation` 对象的列表执行从每个分片并行提取数据的查询。</span><span class="sxs-lookup"><span data-stu-id="86e33-290">The code below shows how the application uses the list of `ShardInformation` objects to perform a query that fetches data from each shard in parallel.</span></span> <span data-ttu-id="86e33-291">查询的详细信息未显示，但是在此示例中，检索的数据包含一个可以保存信息的字符串（例如在分片包含客户的详细信息时保存客户的名称）。</span><span class="sxs-lookup"><span data-stu-id="86e33-291">The details of the query aren't shown, but in this example the data that's retrieved contains a string that could hold information such as the name of a customer if the shards contain the details of customers.</span></span> <span data-ttu-id="86e33-292">结果会聚合到 `ConcurrentBag` 集合中以便由应用程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="86e33-292">The results are aggregated into a `ConcurrentBag` collection for processing by the application.</span></span>

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/master shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="86e33-293">相关模式和指南</span><span class="sxs-lookup"><span data-stu-id="86e33-293">Related patterns and guidance</span></span>

<span data-ttu-id="86e33-294">实现此模式时可能，可能也会与以下模式和指南相关：</span><span class="sxs-lookup"><span data-stu-id="86e33-294">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>
- <span data-ttu-id="86e33-295">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx)（数据一致性入门）。</span><span class="sxs-lookup"><span data-stu-id="86e33-295">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="86e33-296">可能需要对跨不同分片分布的数据保持一致性。</span><span class="sxs-lookup"><span data-stu-id="86e33-296">It might be necessary to maintain consistency for data distributed across different shards.</span></span> <span data-ttu-id="86e33-297">总结了有关维护分布式数据一致性的问题，介绍了不同一致性模型的优点和权衡方案。</span><span class="sxs-lookup"><span data-stu-id="86e33-297">Summarizes the issues surrounding maintaining consistency over distributed data, and describes the benefits and tradeoffs of different consistency models.</span></span>
- <span data-ttu-id="86e33-298">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx)（数据分区指南）。</span><span class="sxs-lookup"><span data-stu-id="86e33-298">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="86e33-299">对数据存储进行分片可能会引入一系列其他问题。</span><span class="sxs-lookup"><span data-stu-id="86e33-299">Sharding a data store can introduce a range of additional issues.</span></span> <span data-ttu-id="86e33-300">介绍与在云中对数据存储进行分区相关的这些问题，以提高可伸缩性、减少争用以及优化性能。</span><span class="sxs-lookup"><span data-stu-id="86e33-300">Describes these issues in relation to partitioning data stores in the cloud to improve scalability, reduce contention, and optimize performance.</span></span>
- <span data-ttu-id="86e33-301">[索引表模式](index-table.md)。</span><span class="sxs-lookup"><span data-stu-id="86e33-301">[Index Table pattern](index-table.md).</span></span> <span data-ttu-id="86e33-302">有时无法只通过分片键的设计来完全支持查询。</span><span class="sxs-lookup"><span data-stu-id="86e33-302">Sometimes it isn't possible to completely support queries just through the design of the shard key.</span></span> <span data-ttu-id="86e33-303">通过指定分片键以外的键，使应用程序可以快速从大型数据存储检索数据。</span><span class="sxs-lookup"><span data-stu-id="86e33-303">Enables an application to quickly retrieve data from a large data store by specifying a key other than the shard key.</span></span>
- <span data-ttu-id="86e33-304">[具体化视图模式](materialized-view.md)。</span><span class="sxs-lookup"><span data-stu-id="86e33-304">[Materialized View pattern](materialized-view.md).</span></span> <span data-ttu-id="86e33-305">为了保持某些查询操作的性能，创建聚合和汇总数据的具体化视图会十分有用，尤其是在此摘要数据基于跨分片分布的信息时。</span><span class="sxs-lookup"><span data-stu-id="86e33-305">To maintain the performance of some query operations, it's useful to create materialized views that aggregate and summarize data, especially if this summary data is based on information that's distributed across shards.</span></span> <span data-ttu-id="86e33-306">介绍如何生成和填充这些视图。</span><span class="sxs-lookup"><span data-stu-id="86e33-306">Describes how to generate and populate these views.</span></span>
- <span data-ttu-id="86e33-307">“提高简单性”博客上的[分片课程](http://www.addsimplicity.com/adding_simplicity_an_engi/2008/08/shard-lessons.html)。</span><span class="sxs-lookup"><span data-stu-id="86e33-307">[Shard Lessons](http://www.addsimplicity.com/adding_simplicity_an_engi/2008/08/shard-lessons.html) on the Adding Simplicity blog.</span></span>
- <span data-ttu-id="86e33-308">CodeFutures 网站上的[数据库分片](http://dbshards.com/database-sharding/)。</span><span class="sxs-lookup"><span data-stu-id="86e33-308">[Database Sharding](http://dbshards.com/database-sharding/) on the CodeFutures web site.</span></span>
- <span data-ttu-id="86e33-309">Max Indelicato 博客上的[可伸缩性策略入门：数据库分片](http://blog.maxindelicato.com/2008/12/scalability-strategies-primer-database-sharding.html)。</span><span class="sxs-lookup"><span data-stu-id="86e33-309">[Scalability Strategies Primer: Database Sharding](http://blog.maxindelicato.com/2008/12/scalability-strategies-primer-database-sharding.html) on Max Indelicato's blog.</span></span>
- <span data-ttu-id="86e33-310">Dare Obasanjo 博客上的[构建可缩放数据库：各种数据库分片方案的优缺点](http://www.25hoursaday.com/weblog/2009/01/16/BuildingScalableDatabasesProsAndConsOfVariousDatabaseShardingSchemes.aspx)。</span><span class="sxs-lookup"><span data-stu-id="86e33-310">[Building Scalable Databases: Pros and Cons of Various Database Sharding Schemes](http://www.25hoursaday.com/weblog/2009/01/16/BuildingScalableDatabasesProsAndConsOfVariousDatabaseShardingSchemes.aspx) on Dare Obasanjo's blog.</span></span>
