---
title: "微服务的域分析"
description: "微服务的域分析"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: c3c353a6b30507369357af4b520a51f8afc2fb8d
ms.sourcegitcommit: 3d6dba524cc7661740bdbaf43870de7728d60a01
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/11/2018
---
# <a name="designing-microservices-domain-analysis"></a><span data-ttu-id="286b2-103">设计微服务：域分析</span><span class="sxs-lookup"><span data-stu-id="286b2-103">Designing microservices: Domain analysis</span></span> 

<span data-ttu-id="286b2-104">微服务的最大挑战之一是定义各个服务的边界。</span><span class="sxs-lookup"><span data-stu-id="286b2-104">One of the biggest challenges of microservices is to define the boundaries of individual services.</span></span> <span data-ttu-id="286b2-105">一般的规则是服务应该只做“一件事”&mdash; 但是，实践这条规则需要经过认真的考虑。</span><span class="sxs-lookup"><span data-stu-id="286b2-105">The general rule is that a service should do "one thing" &mdash; but putting that rule into practice requires careful thought.</span></span> <span data-ttu-id="286b2-106">没有任何机械性的流程可以生成“适当的”设计。</span><span class="sxs-lookup"><span data-stu-id="286b2-106">There is no mechanical process that will produce the "right" design.</span></span> <span data-ttu-id="286b2-107">必须深入考虑业务域、要求和目标。</span><span class="sxs-lookup"><span data-stu-id="286b2-107">You have to think deeply about your business domain, requirements, and goals.</span></span> <span data-ttu-id="286b2-108">否则，最终可能得到一个杂乱无章的设计，它呈现一些不需要的特征，例如隐藏服务之间的依赖关系、紧密耦合，或者界面的设计不佳。</span><span class="sxs-lookup"><span data-stu-id="286b2-108">Otherwise, you can end up with a haphazard design that exhibits some undesirable characteristics, such as hidden dependencies between services, tight coupling, or poorly designed interfaces.</span></span> <span data-ttu-id="286b2-109">本章介绍如何采用域驱动的方法来设计微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-109">In this chapter, we take a domain-driven approach to designing microservices.</span></span> 

<span data-ttu-id="286b2-110">应该围绕业务功能而不是数据访问或消息传递等水平层来设计微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-110">Microservices should be designed around business capabilities, not horizontal layers such as data access or messaging.</span></span> <span data-ttu-id="286b2-111">此外，微服务应具有松散耦合和高功能内聚的特点。</span><span class="sxs-lookup"><span data-stu-id="286b2-111">In addition, they should have loose coupling and high functional cohesion.</span></span> <span data-ttu-id="286b2-112">如果在无需同时更新其他服务的情况下可以更改一个服务，则微服务是松散耦合的。</span><span class="sxs-lookup"><span data-stu-id="286b2-112">Microservices are *loosely coupled* if you can change one service without requiring other services to be updated at the same time.</span></span> <span data-ttu-id="286b2-113">如果微服务具有完善定义的单一目的，例如管理用户帐户或跟踪交付历史记录，则它是内聚性的。</span><span class="sxs-lookup"><span data-stu-id="286b2-113">A microservice is *cohesive* if it has a single, well-defined purpose, such as managing user accounts or tracking delivery history.</span></span> <span data-ttu-id="286b2-114">服务应该封装域知识，并从客户端抽象化知识。</span><span class="sxs-lookup"><span data-stu-id="286b2-114">A service should encapsulate domain knowledge and abstract that knowledge from clients.</span></span> <span data-ttu-id="286b2-115">例如，客户端应该能够在不知道计划算法或如何管理无人机群的情况下安排无人机。</span><span class="sxs-lookup"><span data-stu-id="286b2-115">For example, a client should be able to schedule a drone without knowing the details of the scheduling algorithm or how the drone fleet is managed.</span></span>

<span data-ttu-id="286b2-116">域驱动的设计 (DDD) 提供一个框架，可以让你顺利访问一组完善设计的微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-116">Domain-driven design (DDD) provides a framework that can get you most of the way to a set of well-designed microservices.</span></span> <span data-ttu-id="286b2-117">DDD 包括两个不同的阶段：战略和战术。</span><span class="sxs-lookup"><span data-stu-id="286b2-117">DDD has two distinct phases, strategic and tactical.</span></span> <span data-ttu-id="286b2-118">在战略 DDD 中，可以定义系统的大规模结构。</span><span class="sxs-lookup"><span data-stu-id="286b2-118">In strategic DDD, you are defining the large-scale structure of the system.</span></span> <span data-ttu-id="286b2-119">战略 DDD 有助于确保体系结构专注于业务功能。</span><span class="sxs-lookup"><span data-stu-id="286b2-119">Strategic DDD helps to ensure that your architecture remains focused on business capabilities.</span></span> <span data-ttu-id="286b2-120">战术 DDD 提供一组可用于创建域模型的设计模式。</span><span class="sxs-lookup"><span data-stu-id="286b2-120">Tactical DDD provides a set of design patterns that you can use to create the domain model.</span></span> <span data-ttu-id="286b2-121">这些模式包括实体、聚合和域服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-121">These patterns include entities, aggregates, and domain services.</span></span> <span data-ttu-id="286b2-122">借助这些战术模式，可以设计松散耦合和内聚的微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-122">These tactical patterns will help you to design microservices that are both loosely coupled and cohesive.</span></span>

![](./images/ddd-process.png)

<span data-ttu-id="286b2-123">本章和下一章将引导你完成以下步骤，并将其应用到无人机交付应用程序：</span><span class="sxs-lookup"><span data-stu-id="286b2-123">In this chapter and the next, we'll walk through the following steps, applying them to the Drone Delivery application:</span></span> 

1. <span data-ttu-id="286b2-124">我们首先分析业务域，以了解应用程序的功能要求。</span><span class="sxs-lookup"><span data-stu-id="286b2-124">Start by analyzing the business domain to understand the application's functional requirements.</span></span> <span data-ttu-id="286b2-125">此步骤的输出是域的非正式说明，可将其优化成更正式的一组域模型。</span><span class="sxs-lookup"><span data-stu-id="286b2-125">The output of this step is an informal description of the domain, which can be refined into a more formal set of domain models.</span></span> 

2. <span data-ttu-id="286b2-126">接下来，定义域的边界上下文。</span><span class="sxs-lookup"><span data-stu-id="286b2-126">Next, define the *bounded contexts* of the domain.</span></span> <span data-ttu-id="286b2-127">每个边界上下文包含一个域模型，该模型表示较大应用程序的特定子域。</span><span class="sxs-lookup"><span data-stu-id="286b2-127">Each bounded context contains a domain model that represents a particular subdomain of the larger application.</span></span> 

3. <span data-ttu-id="286b2-128">在边界上下文中，应用战术 DDD 模式以定义实体、聚合和域服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-128">Within a bounded context, apply tactical DDD patterns to define entities, aggregates, and domain services.</span></span> 
 
4. <span data-ttu-id="286b2-129">使用前一步骤的结果可以标识应用程序中的微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-129">Use the results from the previous step to identify the microservices in your application.</span></span>

<span data-ttu-id="286b2-130">本章介绍前三个步骤，并重点讨论 DDD。</span><span class="sxs-lookup"><span data-stu-id="286b2-130">In this chapter, we cover the first three steps, which are primarily concerned with DDD.</span></span> <span data-ttu-id="286b2-131">下一章介绍如何标识微服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-131">In the next chapter, we will identify the microservices.</span></span> <span data-ttu-id="286b2-132">但是，请务必记住，DDD 是迭代的持续过程。</span><span class="sxs-lookup"><span data-stu-id="286b2-132">However, it's important to remember that DDD is an iterative, ongoing process.</span></span> <span data-ttu-id="286b2-133">服务边界不是一成不变的。</span><span class="sxs-lookup"><span data-stu-id="286b2-133">Service boundaries aren't fixed in stone.</span></span> <span data-ttu-id="286b2-134">随着应用程序的演变，你可以决定将某个服务分解成多个较小服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-134">As an application evolves, you may decide to break apart a service into several smaller services.</span></span>

> [!NOTE]
> <span data-ttu-id="286b2-135">本章不会完整介绍全面的域分析。</span><span class="sxs-lookup"><span data-stu-id="286b2-135">This chapter is not meant to show a complete and comprehensive domain analysis.</span></span> <span data-ttu-id="286b2-136">我们有意精简了示例，目的是演示要点。</span><span class="sxs-lookup"><span data-stu-id="286b2-136">We deliberately kept the example brief, in order to illustrate the main points.</span></span> <span data-ttu-id="286b2-137">有关 DDD 的更多背景信息，我们建议阅读 Eric Evans 的 *Domain-Driven Design*（域驱动的设计），该书籍首次引入了该术语。</span><span class="sxs-lookup"><span data-stu-id="286b2-137">For more background on DDD, we recommend Eric Evans' *Domain-Driven Design*, the book that first introduced the term.</span></span> <span data-ttu-id="286b2-138">另一篇极佳的参考文章是 Vaughn Vernon 撰写的 *Implementing Domain-Driven Design*（实施域驱动的设计）。</span><span class="sxs-lookup"><span data-stu-id="286b2-138">Another good reference is *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

## <a name="analyze-the-domain"></a><span data-ttu-id="286b2-139">分析域</span><span class="sxs-lookup"><span data-stu-id="286b2-139">Analyze the domain</span></span>

<span data-ttu-id="286b2-140">借助 DDD 方法可以设计微服务，使每个服务原生都能符合业务功能要求。</span><span class="sxs-lookup"><span data-stu-id="286b2-140">Using a DDD approach will help you to design microservices so that every service forms a natural fit to a functional business requirement.</span></span> <span data-ttu-id="286b2-141">此方法有助于避免组织边界或技术选择左右你的设计，从而让你感到困惑。</span><span class="sxs-lookup"><span data-stu-id="286b2-141">It can help you to avoid the trap of letting organizational boundaries or technology choices dictate your design.</span></span>

<span data-ttu-id="286b2-142">在编写任何代码之前，需要获取所创建的系统的鸟瞰图。</span><span class="sxs-lookup"><span data-stu-id="286b2-142">Before writing any code, you need a bird's eye view of the system that you are creating.</span></span> <span data-ttu-id="286b2-143">DDD 模式首先为业务域建模，然后创建域模型。</span><span class="sxs-lookup"><span data-stu-id="286b2-143">DDD starts by modeling the business domain and creating a *domain model*.</span></span> <span data-ttu-id="286b2-144">域模型是业务域的抽象模型。</span><span class="sxs-lookup"><span data-stu-id="286b2-144">The domain model is an abstract model of the business domain.</span></span> <span data-ttu-id="286b2-145">它可以提取和组织域知识，并为开发人员和域专家提供通用语言。</span><span class="sxs-lookup"><span data-stu-id="286b2-145">It distills and organizes domain knowledge, and provides a common language for developers and domain experts.</span></span> 

<span data-ttu-id="286b2-146">首先，映射所有业务功能及其连接。</span><span class="sxs-lookup"><span data-stu-id="286b2-146">Start by mapping all of the business functions and their connections.</span></span> <span data-ttu-id="286b2-147">这可能需要域专家、软件架构师和其他利益干系人之间展开协作。</span><span class="sxs-lookup"><span data-stu-id="286b2-147">This will likely be a collaborative effort that involves domain experts, software architects, and other stakeholders.</span></span> <span data-ttu-id="286b2-148">不需要使用任何特定的形式。</span><span class="sxs-lookup"><span data-stu-id="286b2-148">You don't need to use any particular formalism.</span></span>  <span data-ttu-id="286b2-149">草绘或者在白板上绘制关系图。</span><span class="sxs-lookup"><span data-stu-id="286b2-149">Sketch a diagram or draw on whiteboard.</span></span>

<span data-ttu-id="286b2-150">在填充关系图时，可以开始标识离散的子域。</span><span class="sxs-lookup"><span data-stu-id="286b2-150">As you fill in the diagram, you may start to identify discrete subdomains.</span></span> <span data-ttu-id="286b2-151">哪些功能密切相关？</span><span class="sxs-lookup"><span data-stu-id="286b2-151">Which functions are closely related?</span></span> <span data-ttu-id="286b2-152">哪些功能是业务的核心，哪些功能提供辅助服务？</span><span class="sxs-lookup"><span data-stu-id="286b2-152">Which functions are core to the business, and which provide ancillary services?</span></span> <span data-ttu-id="286b2-153">依赖项关系图是什么？</span><span class="sxs-lookup"><span data-stu-id="286b2-153">What is the dependency graph?</span></span> <span data-ttu-id="286b2-154">在此初始阶段，不需要考虑技术或实施细节。</span><span class="sxs-lookup"><span data-stu-id="286b2-154">During this initial phase, you aren't concerned with technologies or implementation details.</span></span> <span data-ttu-id="286b2-155">也就是说，应该注意应用程序要在哪个位置与 CRM、付款处理或计费系统等外部系统集成。</span><span class="sxs-lookup"><span data-stu-id="286b2-155">That said, you should note the place where the application will need to integrate with external systems, such as CRM, payment processing, or billing systems.</span></span> 

## <a name="drone-delivery-analyzing-the-business-domain"></a><span data-ttu-id="286b2-156">无人机交付：分析业务域。</span><span class="sxs-lookup"><span data-stu-id="286b2-156">Drone Delivery: Analyzing the business domain.</span></span>

<span data-ttu-id="286b2-157">完成一些初始域分析之后，Fabrikam 团队绘制了一份描绘无人机交付域的草图。</span><span class="sxs-lookup"><span data-stu-id="286b2-157">After some initial domain analysis, the Fabrikam team came up with a rough sketch that depicts the Drone Delivery domain.</span></span>

![](./images/ddd1.svg) 

- <span data-ttu-id="286b2-158">“交货”位于关系图的中心，因为它是业务的核心。</span><span class="sxs-lookup"><span data-stu-id="286b2-158">**Shipping** is placed in the center of the diagram, because it's core to the business.</span></span> <span data-ttu-id="286b2-159">关系图中的其他任何元素都是为了支持此功能。</span><span class="sxs-lookup"><span data-stu-id="286b2-159">Everything else in the diagram exists to enable this functionality.</span></span>
- <span data-ttu-id="286b2-160">“无人机管理”也是业务的核心。</span><span class="sxs-lookup"><span data-stu-id="286b2-160">**Drone management** is also core to the business.</span></span> <span data-ttu-id="286b2-161">与无人机管理密切相关的功能包括**无人机维修**，以及使用**预测分析**来预测无人机何时需要检修和维护。</span><span class="sxs-lookup"><span data-stu-id="286b2-161">Functionality that is closely related to drone management includes **drone repair** and using **predictive analysis** to predict when drones need servicing and maintenance.</span></span> 
- <span data-ttu-id="286b2-162">**ETA 分析**提供取件和交货的估计时间。</span><span class="sxs-lookup"><span data-stu-id="286b2-162">**ETA analysis** provides time estimates for pickup and delivery.</span></span> 
- <span data-ttu-id="286b2-163">如果包裹无法完全由无人机交货，则应用程序可以通过**第三方运输**来安排替代的运输方式。</span><span class="sxs-lookup"><span data-stu-id="286b2-163">**Third-party transportation** will enable the application to schedule alternative transportation methods if a package cannot be shipped entirely by drone.</span></span>
- <span data-ttu-id="286b2-164">**无人机共享**是核心业务的可能扩展。</span><span class="sxs-lookup"><span data-stu-id="286b2-164">**Drone sharing** is a possible extension of the core business.</span></span> <span data-ttu-id="286b2-165">公司的无人机在某些时段可能容量过剩，在这种情况下，可以出租无人机，以避免闲置。</span><span class="sxs-lookup"><span data-stu-id="286b2-165">The company may have excess drone capacity during certain hours, and could rent out drones that would otherwise be idle.</span></span> <span data-ttu-id="286b2-166">初始版本未包括此功能。</span><span class="sxs-lookup"><span data-stu-id="286b2-166">This feature will not be in the initial release.</span></span>
- <span data-ttu-id="286b2-167">**视频监督**是公司以后可以拓展到的另一个领域。</span><span class="sxs-lookup"><span data-stu-id="286b2-167">**Video surveillance** is another area that the company might expand into later.</span></span>
- <span data-ttu-id="286b2-168">**用户帐户**、**开票**和**呼叫中心**是支持核心业务的子域。</span><span class="sxs-lookup"><span data-stu-id="286b2-168">**User accounts**, **Invoicing**, and **Call center** are subdomains that support the core business.</span></span>
 
<span data-ttu-id="286b2-169">请注意，在此流程的此阶段，我们尚未做出有关实施或技术的任何决策。</span><span class="sxs-lookup"><span data-stu-id="286b2-169">Notice that at this point in the process, we haven't made any decisions about implementation or technologies.</span></span> <span data-ttu-id="286b2-170">某些子系统可能涉及到外部软件系统或第三方服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-170">Some of the subsystems may involve external software systems or third-party services.</span></span> <span data-ttu-id="286b2-171">即便如此，应用程序也需要与这些系统和服务进行交互，因此，必须将它们包含在域模型中。</span><span class="sxs-lookup"><span data-stu-id="286b2-171">Even so, the application needs to interact with these systems and services, so it's important to include them in the domain model.</span></span> 

> [!NOTE]
> <span data-ttu-id="286b2-172">如果应用程序依赖于外部系统，则存在一种风险：外部系统的数据架构或 API 会渗入应用程序，最终透露体系结构设计。</span><span class="sxs-lookup"><span data-stu-id="286b2-172">When an application depends on an external system, there is a risk that the external system's data schema or API will leak into your application, ultimately compromising the architectural design.</span></span> <span data-ttu-id="286b2-173">不遵循新式最佳做法，并使用复杂数据架构或过时 API 的旧式系统尤其如此。</span><span class="sxs-lookup"><span data-stu-id="286b2-173">This is particularly true with legacy systems that may not follow modern best practices, and may use convoluted data schemas or obsolete APIs.</span></span> <span data-ttu-id="286b2-174">在这种情况下，必须在这些外部系统与应用程序之间妥善定义边界。</span><span class="sxs-lookup"><span data-stu-id="286b2-174">In that case, it's important to have a well-defined boundary between these external systems and the application.</span></span> <span data-ttu-id="286b2-175">为此，请考虑使用 [Strangler 模式](../patterns/strangler.md)或[防损层模式](../patterns/anti-corruption-layer.md)。</span><span class="sxs-lookup"><span data-stu-id="286b2-175">Consider using the [Strangler Pattern](../patterns/strangler.md) or the [Anti-Corruption Layer Pattern](../patterns/anti-corruption-layer.md) for this purpose.</span></span>

## <a name="define-bounded-contexts"></a><span data-ttu-id="286b2-176">定义边界上下文</span><span class="sxs-lookup"><span data-stu-id="286b2-176">Define bounded contexts</span></span>

<span data-ttu-id="286b2-177">域模型将包含现实世界中事物的表示形式 &mdash; 用户、无人机、包裹，等等。</span><span class="sxs-lookup"><span data-stu-id="286b2-177">The domain model will include representations of real things in the world &mdash; users, drones, packages, and so forth.</span></span> <span data-ttu-id="286b2-178">但这并不意味着，系统的每个部分都需要对相同的事物使用相同的表示形式。</span><span class="sxs-lookup"><span data-stu-id="286b2-178">But that doesn't mean that every part of the system needs to use the same representations for the same things.</span></span> 

<span data-ttu-id="286b2-179">例如，处理无人机维修和预测分析的子系统需要呈现无人机的许多物理特征，例如其维护历史记录、里程、机龄、型号、性能特征，等等。</span><span class="sxs-lookup"><span data-stu-id="286b2-179">For example, subsystems that handle drone repair and predictive analysis will need to represent many physical characteristics drones, such as their maintenance history, mileage, age, model number, performance characteristics, and so on.</span></span> <span data-ttu-id="286b2-180">但是，在安排交付时，我们并不需要关心这些方面。</span><span class="sxs-lookup"><span data-stu-id="286b2-180">But when it's time to schedule a delivery, we don't care about those things.</span></span> <span data-ttu-id="286b2-181">计划子系统只需知道无人机是否可用，以及取件和交货的 ETA。</span><span class="sxs-lookup"><span data-stu-id="286b2-181">The scheduling subsystem only needs to know whether a drone is available, and the ETA for pickup and delivery.</span></span> 

<span data-ttu-id="286b2-182">如果尝试为这两个子系统创建了单个模型，则会不必要地增大复杂性。</span><span class="sxs-lookup"><span data-stu-id="286b2-182">If we tried to create a single model for both of these subsystems, it would be unnecessarily complex.</span></span> <span data-ttu-id="286b2-183">此外，模型会更难得到发展，因为任何更改都需要满足处理不同子系统的多个团队的要求。</span><span class="sxs-lookup"><span data-stu-id="286b2-183">It would also become harder for the model to evolve over time, because any changes will need to satisfy multiple teams working on separate subsystems.</span></span> <span data-ttu-id="286b2-184">因此，更好的做法通常是设计不同的模型，用于在两种不同的上下文中呈现相同的真实实体（在本例中为无人机）。</span><span class="sxs-lookup"><span data-stu-id="286b2-184">Therefore, it's often better to design separate models that represent the same real-world entity (in this case, a drone) in two different contexts.</span></span> <span data-ttu-id="286b2-185">每个模型仅包含其特定上下文中相关的功能和属性。</span><span class="sxs-lookup"><span data-stu-id="286b2-185">Each model contains only the features and attributes that are relevant within its particular context.</span></span>

<span data-ttu-id="286b2-186">在此场合下，“边界上下文”的 DDD 概念可以派上用场。</span><span class="sxs-lookup"><span data-stu-id="286b2-186">This is where the DDD concept of *bounded contexts* comes into play.</span></span> <span data-ttu-id="286b2-187">简单而言，边界上下文是应用特定域模型的域中的边界。</span><span class="sxs-lookup"><span data-stu-id="286b2-187">A bounded context is simply the boundary within a domain where a particular domain model applies.</span></span> <span data-ttu-id="286b2-188">在上图中，我们可以根据各种功能是否共享单个域模型将功能分组。</span><span class="sxs-lookup"><span data-stu-id="286b2-188">Looking at the previous diagram, we can group functionality according to whether various functions will share a single domain model.</span></span> 

![](./images/ddd2.svg) 
 
<span data-ttu-id="286b2-189">边界上下文不一定相互独立。</span><span class="sxs-lookup"><span data-stu-id="286b2-189">Bounded contexts are not necessarily isolated from one another.</span></span> <span data-ttu-id="286b2-190">在此图中，连接边界上下文的实线表示两个边界上下文交互的位置。</span><span class="sxs-lookup"><span data-stu-id="286b2-190">In this diagram, the solid lines connecting the bounded contexts represent places where two bounded contexts interact.</span></span> <span data-ttu-id="286b2-191">例如，“交货”依赖于“用户帐户”来获取有关客户的信息，并依赖于“无人机管理”来安排机群中的无人机。</span><span class="sxs-lookup"><span data-stu-id="286b2-191">For example, Shipping depends on User Accounts to get information about customers, and on Drone Management to schedule drones from the fleet.</span></span>

<span data-ttu-id="286b2-192">在 *Domain Driven Design*（域驱动的设计）一书中，Eric Evans 描述了当某个域模型与另一个边界上下文交互时，保持该模型完整性的多种模式。</span><span class="sxs-lookup"><span data-stu-id="286b2-192">In the book *Domain Driven Design*, Eric Evans describes several patterns for maintaining the integrity of a domain model when it interacts with another bounded context.</span></span> <span data-ttu-id="286b2-193">微服务的主要原则之一是服务通过完善定义的 API 进行通信。</span><span class="sxs-lookup"><span data-stu-id="286b2-193">One of the main principles of microservices is that services communicate through well-defined APIs.</span></span> <span data-ttu-id="286b2-194">此方法对应于两种模式，即 Evans 所说的“开放主机服务”和“发布语言”。</span><span class="sxs-lookup"><span data-stu-id="286b2-194">This approach corresponds to two patterns that Evans calls Open Host Service and Published Language.</span></span> <span data-ttu-id="286b2-195">“开放主机服务”的思路是子系统针对与它通信的其他子系统定义一个正式协议 (API)。</span><span class="sxs-lookup"><span data-stu-id="286b2-195">The idea of Open Host Service is that a subsystem defines a formal protocol (API) for other subsystems to communicate with it.</span></span> <span data-ttu-id="286b2-196">“发布语言”扩展了这种思路，它以其他团队可以用来编写客户端的形式发布 API。</span><span class="sxs-lookup"><span data-stu-id="286b2-196">Published Language extends this idea by publishing the API in a form that other teams can use to write clients.</span></span> <span data-ttu-id="286b2-197">[API 设计](./api-design.md)一章介绍了如何使用 [OpenAPI 规范](https://www.openapis.org/specification/repo)（以前称为 Swagger）来为 REST API 定义语言无关的接口说明（以 JSON 或 YAML 格式表示）。</span><span class="sxs-lookup"><span data-stu-id="286b2-197">In the chapter on [API Design](./api-design.md), we discuss using [OpenAPI Specification](https://www.openapis.org/specification/repo) (formerly known as Swagger) to define language-agnostic interface descriptions for REST APIs, expressed in JSON or YAML format.</span></span>

<span data-ttu-id="286b2-198">本教程的余下部分侧重于“交货”边界上下文。</span><span class="sxs-lookup"><span data-stu-id="286b2-198">For the rest of this journey, we will focus on the Shipping bounded context.</span></span> 

## <a name="tactical-ddd"></a><span data-ttu-id="286b2-199">战术 DDD</span><span class="sxs-lookup"><span data-stu-id="286b2-199">Tactical DDD</span></span>

<span data-ttu-id="286b2-200">在 DDD 的战略阶段，我们要绘制业务域的关系图，并定义域模型的边界上下文。</span><span class="sxs-lookup"><span data-stu-id="286b2-200">During the strategic phase of DDD, you are mapping out the business domain and defining bounded contexts for your domain models.</span></span> <span data-ttu-id="286b2-201">在战术 DDD 阶段，我们要更精确地定义域模型。</span><span class="sxs-lookup"><span data-stu-id="286b2-201">Tactical DDD is when you define your domain models with more precision.</span></span> <span data-ttu-id="286b2-202">战术模式在单个边界上下文中应用。</span><span class="sxs-lookup"><span data-stu-id="286b2-202">The tactical patterns are applied within a single bounded context.</span></span> <span data-ttu-id="286b2-203">在微服务体系结构中，我们对实体和聚合模式特别感兴趣。</span><span class="sxs-lookup"><span data-stu-id="286b2-203">In a microservices architecture, we are particularly interested in the entity and aggregate patterns.</span></span> <span data-ttu-id="286b2-204">应用这些模式有助于标识应用程序中服务的自然边界（请参阅[下一章](./microservice-boundaries.md)）。</span><span class="sxs-lookup"><span data-stu-id="286b2-204">Applying these patterns will help us to identify natural boundaries for the services in our application (see [next chapter](./microservice-boundaries.md)).</span></span> <span data-ttu-id="286b2-205">作为一般原则，微服务应小于聚合，且不大于边界上下文。</span><span class="sxs-lookup"><span data-stu-id="286b2-205">As a general principle, a microservice should be no smaller than an aggregate, and no larger than a bounded context.</span></span> <span data-ttu-id="286b2-206">首先，让我们了解战术模式。</span><span class="sxs-lookup"><span data-stu-id="286b2-206">First, we'll review the tactical patterns.</span></span> <span data-ttu-id="286b2-207">然后，我们对无人机交付应用程序中的“交货”边界上下文应用这些模式。</span><span class="sxs-lookup"><span data-stu-id="286b2-207">Then we'll apply them to the Shipping bounded context in the Drone Delivery application.</span></span> 

### <a name="overview-of-the-tactical-patterns"></a><span data-ttu-id="286b2-208">战术模式概述</span><span class="sxs-lookup"><span data-stu-id="286b2-208">Overview of the tactical patterns</span></span>

<span data-ttu-id="286b2-209">本部分提供战术 DDD 模式的简要概述，如果你已熟悉 DDD，则可以跳过本部分。</span><span class="sxs-lookup"><span data-stu-id="286b2-209">This section provides a brief summary of the tactical DDD patterns, so if you are already familiar with DDD, you can probably skip this section.</span></span> <span data-ttu-id="286b2-210">Eric Evans 著作的第 5 &ndash; 6 章，以及 Vaughn Vernon 的 *Implementing Domain-Driven Design*（实施域驱动的设计）一书中更详细地介绍了这些模式。</span><span class="sxs-lookup"><span data-stu-id="286b2-210">The patterns are described in more detail in chapters 5 &ndash; 6 of Eric Evans' book, and in *Implementing Domain-Driven Design* by Vaughn Vernon.</span></span> 

![](./images/ddd-patterns.png)

<span data-ttu-id="286b2-211">**实体**。</span><span class="sxs-lookup"><span data-stu-id="286b2-211">**Entities**.</span></span> <span data-ttu-id="286b2-212">实体是一直保持唯一标识的对象。</span><span class="sxs-lookup"><span data-stu-id="286b2-212">An entity is an object with a unique identity that persists over time.</span></span> <span data-ttu-id="286b2-213">例如，在银行应用程序中，客户和帐户就是实体。</span><span class="sxs-lookup"><span data-stu-id="286b2-213">For example, in a banking application, customers and accounts would be entities.</span></span> 

- <span data-ttu-id="286b2-214">实体在系统中有唯一的标识符，使用该标识符可以查找和检索该实体。</span><span class="sxs-lookup"><span data-stu-id="286b2-214">An entity has a unique identifier in the system, which can be used to look up or retrieve the entity.</span></span> <span data-ttu-id="286b2-215">这并不意味着，该标识符始终直接向用户公开。</span><span class="sxs-lookup"><span data-stu-id="286b2-215">That doesn't mean the identifier is always exposed directly to users.</span></span> <span data-ttu-id="286b2-216">它可能是数据库中的 GUID 或主键。</span><span class="sxs-lookup"><span data-stu-id="286b2-216">It could be a GUID or a primary key in a database.</span></span> 
- <span data-ttu-id="286b2-217">一个标识可以跨多个边界上下文，并可能保留到应用程序生存期结束之后。</span><span class="sxs-lookup"><span data-stu-id="286b2-217">An identity may span multiple bounded contexts, and may endure beyond the lifetime of the application.</span></span> <span data-ttu-id="286b2-218">例如，银行帐号或政府颁发的身份证号不会与特定应用程序的生存期相关联。</span><span class="sxs-lookup"><span data-stu-id="286b2-218">For example, bank account numbers or government-issued IDs are not tied to the lifetime of a particular application.</span></span>
- <span data-ttu-id="286b2-219">实体的属性可随时变化。</span><span class="sxs-lookup"><span data-stu-id="286b2-219">The attributes of an entity may change over time.</span></span> <span data-ttu-id="286b2-220">例如，某人的姓名或地址可能有变化，但他（她）仍是同一个人。</span><span class="sxs-lookup"><span data-stu-id="286b2-220">For example, a person's name or address might change, but they are still the same person.</span></span> 
- <span data-ttu-id="286b2-221">一个实体可以包含对其他实体的引用。</span><span class="sxs-lookup"><span data-stu-id="286b2-221">An entity can hold references to other entities.</span></span>
 
<span data-ttu-id="286b2-222">**值对象**。</span><span class="sxs-lookup"><span data-stu-id="286b2-222">**Value objects**.</span></span> <span data-ttu-id="286b2-223">值对象没有标识。</span><span class="sxs-lookup"><span data-stu-id="286b2-223">A value object has no identity.</span></span> <span data-ttu-id="286b2-224">它只由其属性值定义。</span><span class="sxs-lookup"><span data-stu-id="286b2-224">It is defined only by the values of its attributes.</span></span> <span data-ttu-id="286b2-225">值对象也是不可变的。</span><span class="sxs-lookup"><span data-stu-id="286b2-225">Value objects are also immutable.</span></span> <span data-ttu-id="286b2-226">若要更新值对象，始终需要创建一个新实例来替换旧实例。</span><span class="sxs-lookup"><span data-stu-id="286b2-226">To update a value object, you always create a new instance to replace the old one.</span></span> <span data-ttu-id="286b2-227">值对象可以包含用于封装域逻辑的方法，但这些方法不应该给对象的状态产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="286b2-227">Value objects can have methods that encapsulate domain logic, but those methods should have no side-effects on the object's state.</span></span> <span data-ttu-id="286b2-228">值对象的典型示例包括颜色、日期时间和货币值。</span><span class="sxs-lookup"><span data-stu-id="286b2-228">Typical examples of value objects include colors, dates and times, and currency values.</span></span> 

<span data-ttu-id="286b2-229">**聚合**。</span><span class="sxs-lookup"><span data-stu-id="286b2-229">**Aggregates**.</span></span> <span data-ttu-id="286b2-230">聚合定义一个或多个实体的一致性边界。</span><span class="sxs-lookup"><span data-stu-id="286b2-230">An aggregate defines a consistency boundary around one or more entities.</span></span> <span data-ttu-id="286b2-231">一个聚合只包含一个根实体。</span><span class="sxs-lookup"><span data-stu-id="286b2-231">Exactly one entity in an aggregate is the root.</span></span> <span data-ttu-id="286b2-232">可以使用根实体的标识符执行查找。</span><span class="sxs-lookup"><span data-stu-id="286b2-232">Lookup is done using the root entity's identifier.</span></span> <span data-ttu-id="286b2-233">聚合中的其他任何实体是根的子级，由从根开始的后续指针引用。</span><span class="sxs-lookup"><span data-stu-id="286b2-233">Any other entities in the aggregate are children of the root, and are referenced by following pointers from the root.</span></span> 

<span data-ttu-id="286b2-234">聚合的作用是为事务不可变性建模。</span><span class="sxs-lookup"><span data-stu-id="286b2-234">The purpose of an aggregate is to model transactional invariants.</span></span> <span data-ttu-id="286b2-235">现实世界中的事物具有复杂的关系网。</span><span class="sxs-lookup"><span data-stu-id="286b2-235">Things in the real world have complex webs of relationships.</span></span> <span data-ttu-id="286b2-236">客户创建订单，订单包含产品，产品有供应商，等等。</span><span class="sxs-lookup"><span data-stu-id="286b2-236">Customers create orders, orders contain products, products have suppliers, and so on.</span></span> <span data-ttu-id="286b2-237">如果应用程序修改了多个相关对象，如何保证一致性？</span><span class="sxs-lookup"><span data-stu-id="286b2-237">If the application modifies several related objects, how does it guarantee consistency?</span></span> <span data-ttu-id="286b2-238">如何跟踪并实施不可变性？</span><span class="sxs-lookup"><span data-stu-id="286b2-238">How do we keep track of invariants and enforce them?</span></span>  

<span data-ttu-id="286b2-239">传统应用程序通常使用数据库事务来实施一致性。</span><span class="sxs-lookup"><span data-stu-id="286b2-239">Traditional applications have often used database transactions to enforce consistency.</span></span> <span data-ttu-id="286b2-240">但是，在分布式应用程序中，这种做法通常不可行。</span><span class="sxs-lookup"><span data-stu-id="286b2-240">In a distributed application, however, that's often not feasible.</span></span> <span data-ttu-id="286b2-241">单个业务事务可能跨越多个数据存储、长时间运行，或者涉及第三方服务。</span><span class="sxs-lookup"><span data-stu-id="286b2-241">A single business transaction may span multiple data stores, or may be long running, or may involve third-party services.</span></span> <span data-ttu-id="286b2-242">最终由应用程序而不是数据层来实施域所需的不可变性。</span><span class="sxs-lookup"><span data-stu-id="286b2-242">Ultimately it's up to the application, not the data layer, to enforce the invariants required for the domain.</span></span> <span data-ttu-id="286b2-243">这就是要为聚合建模的目的。</span><span class="sxs-lookup"><span data-stu-id="286b2-243">That's what aggregates are meant to model.</span></span>

> [!NOTE]
> <span data-ttu-id="286b2-244">聚合可以包含单个实体且不包含子实体。</span><span class="sxs-lookup"><span data-stu-id="286b2-244">An aggregate might consist of a single entity, without child entities.</span></span> <span data-ttu-id="286b2-245">聚合的定义由事务边界确定。</span><span class="sxs-lookup"><span data-stu-id="286b2-245">What makes it an aggregate is the transactional boundary.</span></span>

<span data-ttu-id="286b2-246">**域和应用程序服务**。</span><span class="sxs-lookup"><span data-stu-id="286b2-246">**Domain and application services**.</span></span> <span data-ttu-id="286b2-247">在 DDD 术语中，服务是实现某种逻辑且不保存任何状态的对象。</span><span class="sxs-lookup"><span data-stu-id="286b2-247">In DDD terminology, a service is an object that implements some logic without holding any state.</span></span> <span data-ttu-id="286b2-248">Evans 对封装域逻辑的域服务，以及提供技术功能（例如用户身份验证或发送短信）的应用程序服务做了区分。</span><span class="sxs-lookup"><span data-stu-id="286b2-248">Evans distinguishes between *domain services*, which encapsulate domain logic, and *application services*, which provide technical functionality, such as user authentication or sending an SMS message.</span></span> <span data-ttu-id="286b2-249">域服务通常用来对跨多个实体的行为建模。</span><span class="sxs-lookup"><span data-stu-id="286b2-249">Domain services are often used to model behavior that spans multiple entities.</span></span> 

> [!NOTE]
> <span data-ttu-id="286b2-250">软件开发中广泛使用了“服务”一词。</span><span class="sxs-lookup"><span data-stu-id="286b2-250">The term *service* is overloaded in software development.</span></span> <span data-ttu-id="286b2-251">此处的定义不直接与微服务相关。</span><span class="sxs-lookup"><span data-stu-id="286b2-251">The definition here is not directly related to microservices.</span></span>

<span data-ttu-id="286b2-252">**域事件**。</span><span class="sxs-lookup"><span data-stu-id="286b2-252">**Domain events**.</span></span> <span data-ttu-id="286b2-253">发生某种情况时，可以使用域事件来通知系统的其他部件。</span><span class="sxs-lookup"><span data-stu-id="286b2-253">Domain events can be used to notify other parts of the system when something happens.</span></span> <span data-ttu-id="286b2-254">顾名思义，域事件应该表示域中发生的某些情况。</span><span class="sxs-lookup"><span data-stu-id="286b2-254">As the name suggests, domain events should mean something within the domain.</span></span> <span data-ttu-id="286b2-255">例如，“在表中插入了记录”不是域事件。</span><span class="sxs-lookup"><span data-stu-id="286b2-255">For example, "a record was inserted into a table" is not a domain event.</span></span> <span data-ttu-id="286b2-256">“已取消交付”是域事件。</span><span class="sxs-lookup"><span data-stu-id="286b2-256">"A delivery was cancelled" is a domain event.</span></span> <span data-ttu-id="286b2-257">域事件与微服务体系结构密切相关。</span><span class="sxs-lookup"><span data-stu-id="286b2-257">Domain events are especially relevant in a microservices architecture.</span></span> <span data-ttu-id="286b2-258">由于微服务是分发式的且不共享数据存储，微服务可通过域事件来相互协调。</span><span class="sxs-lookup"><span data-stu-id="286b2-258">Because microservices are distributed and don't share data stores, domain events provide a way for microservices to coordinate with each other.</span></span> <span data-ttu-id="286b2-259">[服务间通信](./interservice-communication.md)一章更详细介绍了异步消息传递。</span><span class="sxs-lookup"><span data-stu-id="286b2-259">The chapter [Interservice communication](./interservice-communication.md) discusses asynchronous messaging in more detail.</span></span>
 
<span data-ttu-id="286b2-260">还有其他几种 DDD 模式未在此处列出，包括工厂、存储库和模块。</span><span class="sxs-lookup"><span data-stu-id="286b2-260">There are a few other DDD patterns not listed here, including factories, repositories, and modules.</span></span> <span data-ttu-id="286b2-261">实施微服务时，这些模式可能十分有用；但是，在微服务之间设计边界时，它们作用不大。</span><span class="sxs-lookup"><span data-stu-id="286b2-261">These can be useful patterns for when you are implementing a microservice, but they are less relevant when designing the boundaries between microservice.</span></span>

## <a name="drone-delivery-applying-the-patterns"></a><span data-ttu-id="286b2-262">无人机交付：应用模式</span><span class="sxs-lookup"><span data-stu-id="286b2-262">Drone delivery: Applying the patterns</span></span>

<span data-ttu-id="286b2-263">首先，我们探讨“交货”边界上下文必须处理的方案。</span><span class="sxs-lookup"><span data-stu-id="286b2-263">We start with the scenarios that the Shipping bounded context must handle.</span></span>

- <span data-ttu-id="286b2-264">某个客户可以请求派遣无人机从已注册到无人机交付服务的公司取件。</span><span class="sxs-lookup"><span data-stu-id="286b2-264">A customer can request a drone to pick up goods from a business that is registered with the drone delivery service.</span></span>
- <span data-ttu-id="286b2-265">寄件人生成了一个标记（条形码或 RFID）并粘贴在包裹上。</span><span class="sxs-lookup"><span data-stu-id="286b2-265">The sender generates a tag (barcode or RFID) to put on the package.</span></span> 
- <span data-ttu-id="286b2-266">无人机将会收取包裹，然后将包裹从源位置交付到目标位置。</span><span class="sxs-lookup"><span data-stu-id="286b2-266">A drone will pick up and deliver a package from the source location to the destination location.</span></span>
- <span data-ttu-id="286b2-267">当客户安排交付时，系统将会根据路线信息、天气情况和历史数据提供 ETA。</span><span class="sxs-lookup"><span data-stu-id="286b2-267">When a customer schedules a delivery, the system provides an ETA based on route information, weather conditions, and historical data.</span></span> 
- <span data-ttu-id="286b2-268">当无人机起飞时，用户可以跟踪当前位置和最新的 ETA。</span><span class="sxs-lookup"><span data-stu-id="286b2-268">When the drone is in flight, a user can track the current location and the latest ETA.</span></span> 
- <span data-ttu-id="286b2-269">在无人机收取包裹之前，客户可以取消交付。</span><span class="sxs-lookup"><span data-stu-id="286b2-269">Until a drone has picked up the package, the customer can cancel a delivery.</span></span>
- <span data-ttu-id="286b2-270">完成交付时，客户将收到通知。</span><span class="sxs-lookup"><span data-stu-id="286b2-270">The customer is notified when the delivery is completed.</span></span>
- <span data-ttu-id="286b2-271">寄件人可以请求客户提供签名或指纹形式的交付信息。</span><span class="sxs-lookup"><span data-stu-id="286b2-271">The sender can request delivery confirmation from the customer, in the form of a signature or finger print.</span></span>
- <span data-ttu-id="286b2-272">用户可以查找已完成交付的历史记录。</span><span class="sxs-lookup"><span data-stu-id="286b2-272">Users can look up the history of a completed delivery.</span></span>

<span data-ttu-id="286b2-273">在这些方案中，开发团队确定了以下**实体**。</span><span class="sxs-lookup"><span data-stu-id="286b2-273">From these scenarios, the development team identified the following **entities**.</span></span>

- <span data-ttu-id="286b2-274">交付</span><span class="sxs-lookup"><span data-stu-id="286b2-274">Delivery</span></span>
- <span data-ttu-id="286b2-275">程序包</span><span class="sxs-lookup"><span data-stu-id="286b2-275">Package</span></span>
- <span data-ttu-id="286b2-276">无人机</span><span class="sxs-lookup"><span data-stu-id="286b2-276">Drone</span></span>
- <span data-ttu-id="286b2-277">帐户</span><span class="sxs-lookup"><span data-stu-id="286b2-277">Account</span></span>
- <span data-ttu-id="286b2-278">确认</span><span class="sxs-lookup"><span data-stu-id="286b2-278">Confirmation</span></span>
- <span data-ttu-id="286b2-279">通知</span><span class="sxs-lookup"><span data-stu-id="286b2-279">Notification</span></span>
- <span data-ttu-id="286b2-280">标记</span><span class="sxs-lookup"><span data-stu-id="286b2-280">Tag</span></span>

<span data-ttu-id="286b2-281">前四个项（“交付”、“包裹”、“无人机”和“帐户”）都是表示事务一致性边界的**聚合**。</span><span class="sxs-lookup"><span data-stu-id="286b2-281">The first four, Delivery, Package, Drone, and Account, are all **aggregates** that represent transactional consistency boundaries.</span></span> <span data-ttu-id="286b2-282">“确认”和“通知”是“交付”的子实体，“标记”是“包裹”的子实体。</span><span class="sxs-lookup"><span data-stu-id="286b2-282">Confirmations and Notifications are child entities of Deliveries, and Tags are child entities of Packages.</span></span> 

<span data-ttu-id="286b2-283">此设计中的**值对象**包括“位置”、“ETA”、“包裹重量”和“包裹大小”。</span><span class="sxs-lookup"><span data-stu-id="286b2-283">The **value objects** in this design include Location, ETA, PackageWeight, and PackageSize.</span></span> 

<span data-ttu-id="286b2-284">为便于演示，下面提供了“交付”聚合的 UML 关系图。</span><span class="sxs-lookup"><span data-stu-id="286b2-284">To illustrate, here is a UML diagram of the Delivery aggregate.</span></span> <span data-ttu-id="286b2-285">请注意，该聚合包含对其他聚合（包括“帐户”、“包裹”和“无人机”）的引用。</span><span class="sxs-lookup"><span data-stu-id="286b2-285">Notice that it holds references to other aggregates, including Account, Package, and Drone.</span></span>

![](./images/delivery-entity.png)

<span data-ttu-id="286b2-286">有两个域事件：</span><span class="sxs-lookup"><span data-stu-id="286b2-286">There are two domain events:</span></span>

- <span data-ttu-id="286b2-287">当无人机起飞时，“无人机”实体将发送 DroneStatus 事件，用于描述无人机的位置和状态（飞行中、已着陆）。</span><span class="sxs-lookup"><span data-stu-id="286b2-287">While a drone is in flight, the Drone entity sends DroneStatus events that describe the drone's location and status (in-flight, landed).</span></span>

- <span data-ttu-id="286b2-288">每当交付阶段发生更改时，“交付”实体将发送 DeliveryTracking 事件。</span><span class="sxs-lookup"><span data-stu-id="286b2-288">The Delivery entity sends DeliveryTracking events whenever the stage of a delivery changes.</span></span> <span data-ttu-id="286b2-289">这些事件包括 DeliveryCreated、DeliveryRescheduled、DeliveryHeadedToDropoff 和 DeliveryCompleted。</span><span class="sxs-lookup"><span data-stu-id="286b2-289">These include DeliveryCreated, DeliveryRescheduled, DeliveryHeadedToDropoff, and DeliveryCompleted.</span></span> 

<span data-ttu-id="286b2-290">请注意，这些事件描述域模型中有意义的事物。</span><span class="sxs-lookup"><span data-stu-id="286b2-290">Notice that these events describe things that are meaningful within the domain model.</span></span> <span data-ttu-id="286b2-291">它们描述有关域的某些信息，但不与特定的编程语言构造相关。</span><span class="sxs-lookup"><span data-stu-id="286b2-291">They describe something about the domain, and aren't tied to a particular programming language construct.</span></span>

<span data-ttu-id="286b2-292">开发团队还确定了另一个功能领域，但该功能领域并不与前面所述的任何实体紧密相关。</span><span class="sxs-lookup"><span data-stu-id="286b2-292">The development team identified one more area of functionality, which doesn't fit neatly into any of the entities described so far.</span></span> <span data-ttu-id="286b2-293">系统的某个部件必须协调有关安排或更新交付的所有步骤。</span><span class="sxs-lookup"><span data-stu-id="286b2-293">Some part of the system must coordinate all of the steps involved in scheduling or updating a delivery.</span></span> <span data-ttu-id="286b2-294">因此，开发团队在设计中添加了两个**域服务**：一个计划程序（用于协调步骤），以及一个监督程序（用于监视每个步骤的状态，以检测是否有任何步骤失败或超时）。这是[计划程序代理监督程序模式](../patterns/scheduler-agent-supervisor.md)的一个变体。</span><span class="sxs-lookup"><span data-stu-id="286b2-294">Therefore, the development team added two **domain services** to the design: a *Scheduler* that coordinates the steps, and a *Supervisor* that monitors the status of each step, in order to detect whether any steps have failed or timed out. This is a variation of the [Scheduler Agent Supervisor pattern](../patterns/scheduler-agent-supervisor.md).</span></span>

![](./images/drone-ddd.png)

> [!div class="nextstepaction"]
> [<span data-ttu-id="286b2-295">标识微服务边界</span><span class="sxs-lookup"><span data-stu-id="286b2-295">Identifying microservice boundaries</span></span>](./microservice-boundaries.md)
