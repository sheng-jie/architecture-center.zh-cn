---
title: "微服务的 CI/CD"
description: "微服务的持续集成和持续交付"
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: 7d8a81b7bc236e50d722a68a0115b9220d4e094f
ms.sourcegitcommit: 786bafefc731245414c3c1510fc21027afe303dc
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/12/2017
---
# <a name="designing-microservices-continuous-integration"></a><span data-ttu-id="81940-103">设计微服务：持续集成</span><span class="sxs-lookup"><span data-stu-id="81940-103">Designing microservices: Continuous integration</span></span>

<span data-ttu-id="81940-104">要在微服务上获得成功，必须实施持续集成和持续交付 (CI/CD)。</span><span class="sxs-lookup"><span data-stu-id="81940-104">Continuous integration and continuous delivery (CI/CD) are a key requirement for achieving success with microservices.</span></span> <span data-ttu-id="81940-105">没有制定合理的 CI/CD 流程，就无法实现微服务具备的敏捷性。</span><span class="sxs-lookup"><span data-stu-id="81940-105">Without a good CI/CD process, you will not achieve the agility that microservices promise.</span></span> <span data-ttu-id="81940-106">如果为不同的服务使用多个代码库和异构生成环境，则为微服务实施 CI/CD 会有一定的难度。</span><span class="sxs-lookup"><span data-stu-id="81940-106">Some of the CI/CD challenges for microservices arise from having multiple code bases and heterogenous build environments for the various services.</span></span> <span data-ttu-id="81940-107">本章介绍具体的难题，并推荐一些问题解决方法。</span><span class="sxs-lookup"><span data-stu-id="81940-107">This chapter describes the challenges and recommends some approaches to the problem.</span></span>

![](./images/ci-cd.png)

<span data-ttu-id="81940-108">加速发布周期是采用微服务体系结构的最重要原因之一。</span><span class="sxs-lookup"><span data-stu-id="81940-108">Faster release cycles are one of the biggest reasons to adopt a microservices architecture.</span></span> 

<span data-ttu-id="81940-109">在单纯的整体应用程序中，有一个生成管道的输出就是应用程序可执行文件。</span><span class="sxs-lookup"><span data-stu-id="81940-109">In a purely monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="81940-110">所有开发工作都会馈送到此管道中。</span><span class="sxs-lookup"><span data-stu-id="81940-110">All development work feeds into this pipeline.</span></span> <span data-ttu-id="81940-111">如果发现了高优先级 bug，则必须集成、测试然后发布修复程序，这可能会延缓新功能的发布。</span><span class="sxs-lookup"><span data-stu-id="81940-111">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="81940-112">运用合理构造的模块并使用功能分支来最小化代码更改造成的影响确实可以缓解这些问题。</span><span class="sxs-lookup"><span data-stu-id="81940-112">It's true that you can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="81940-113">但是，随着应用程序变得越来越复杂和更多功能的添加，整体应用程序的发布过程往往会变得更加脆弱且可能中断。</span><span class="sxs-lookup"><span data-stu-id="81940-113">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span> 

<span data-ttu-id="81940-114">根据微服务的理念，永远不应出现一个要让每个团队遵守的冗长发布周期。</span><span class="sxs-lookup"><span data-stu-id="81940-114">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="81940-115">生成服务“A”的团队随时可以发布更新，而无需等到已合并、测试并部署服务“B”中的更改。</span><span class="sxs-lookup"><span data-stu-id="81940-115">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span> <span data-ttu-id="81940-116">要实现此目的，CI/CD 过程至关重要。</span><span class="sxs-lookup"><span data-stu-id="81940-116">The CI/CD process is critical to making this possible.</span></span> <span data-ttu-id="81940-117">发布管道必须自动化且高度可靠，以尽量降低部署更新存在的风险。</span><span class="sxs-lookup"><span data-stu-id="81940-117">Your release pipeline must be automated and highly reliable, so that the risks of deploying updates are minimized.</span></span> <span data-ttu-id="81940-118">如果每天或一天中多次向生产环境发布更新，则回退或服务中断的情况必须很少出现。</span><span class="sxs-lookup"><span data-stu-id="81940-118">If you are releasing to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="81940-119">同时，如果部署了错误的更新，则必须通过可靠的方式快速回滚或者前滚到以前的服务版本。</span><span class="sxs-lookup"><span data-stu-id="81940-119">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

![](./images/cicd-monolith.png)

<span data-ttu-id="81940-120">当我们讨论 CI/CD 时，其实是在讨论多个相关的过程：持续集成、持续交付和持续部署。</span><span class="sxs-lookup"><span data-stu-id="81940-120">When we talk about CI/CD, we are really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="81940-121">持续集成是指频繁地将代码更改合并到主分支，并使用自动化的生成和测试过程来确保主分支中的代码始终具有生产级别的质量。</span><span class="sxs-lookup"><span data-stu-id="81940-121">Continuous integration means that code changes are frequently merged into the main branch, using automated build and test processes to ensure that  code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="81940-122">持续交付是指将经历 CI 过程的代码更改自动发布到类似于生产的环境。</span><span class="sxs-lookup"><span data-stu-id="81940-122">Continuous delivery means that code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="81940-123">部署到实时生产环境可能需要人工批准，否则可自动进行。</span><span class="sxs-lookup"><span data-stu-id="81940-123">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="81940-124">目标是让代码始终做好部署到生产环境的准备。</span><span class="sxs-lookup"><span data-stu-id="81940-124">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="81940-125">持续部署是指将经历 CI/CD 过程的代码更改自动部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="81940-125">Continuous deployment means that code changes that pass the CI/CD process are automatically deployed into production.</span></span>

<span data-ttu-id="81940-126">在 Kubernetes 和微服务的上下文中，CI 阶段涉及到生成和测试容器映像，然后将这些映像推送到容器注册表。</span><span class="sxs-lookup"><span data-stu-id="81940-126">In the context of Kubernetes and microservices, the CI stage is concerned with building and testing container images, and pushing those images to a container registry.</span></span> <span data-ttu-id="81940-127">在部署阶段，将会更新 pod 规范以拾取最新的生产映像。</span><span class="sxs-lookup"><span data-stu-id="81940-127">In the deployment stage, pod specs are updated to pick up the latest production image.</span></span>

## <a name="challenges"></a><span data-ttu-id="81940-128">挑战</span><span class="sxs-lookup"><span data-stu-id="81940-128">Challenges</span></span>

- <span data-ttu-id="81940-129">**许多小型的独立代码库**。</span><span class="sxs-lookup"><span data-stu-id="81940-129">**Many small independent code bases**.</span></span> <span data-ttu-id="81940-130">每个团队负责使用自己的生成管道生成自己的服务。</span><span class="sxs-lookup"><span data-stu-id="81940-130">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="81940-131">在某些组织中，团队可能会使用单独的代码存储库。</span><span class="sxs-lookup"><span data-stu-id="81940-131">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="81940-132">这可能导致出现这种情况：各个团队对系统的生成方式各不相同，组织中没有人知道如何部署整个应用程序。</span><span class="sxs-lookup"><span data-stu-id="81940-132">This could lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="81940-133">例如，在灾难恢复方案中，如果需要快速部署到新群集，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="81940-133">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>   

- <span data-ttu-id="81940-134">**多种语言和框架**。</span><span class="sxs-lookup"><span data-stu-id="81940-134">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="81940-135">如果每个团队混合使用其自身的技术，则可能难以创建一套可在整个组织中运用的单一生成过程。</span><span class="sxs-lookup"><span data-stu-id="81940-135">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="81940-136">生成过程必须足够灵活，使每个团队能够根据所选的语言或框架来改编它。</span><span class="sxs-lookup"><span data-stu-id="81940-136">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span> 

- <span data-ttu-id="81940-137">**集成和负载测试**。</span><span class="sxs-lookup"><span data-stu-id="81940-137">**Integration and load testing**.</span></span> <span data-ttu-id="81940-138">如果团队根据自己的步调发布更新，则可能难以设计可靠的端到端测试，尤其是当服务彼此依赖时。</span><span class="sxs-lookup"><span data-stu-id="81940-138">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="81940-139">此外，运行整个生产群集可能费用不菲，每个团队不太可能只是出于测试目的，以生产规模运行整个群集。</span><span class="sxs-lookup"><span data-stu-id="81940-139">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will be able to run its own full cluster at production scales, just for testing.</span></span> 

- <span data-ttu-id="81940-140">**发布管理**。</span><span class="sxs-lookup"><span data-stu-id="81940-140">**Release management**.</span></span> <span data-ttu-id="81940-141">每个团队应该能够将更新部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="81940-141">Every team should have the ability to deploy an update to production.</span></span> <span data-ttu-id="81940-142">这并不意味着每个团队成员都有权这样做。</span><span class="sxs-lookup"><span data-stu-id="81940-142">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="81940-143">但是，设置集中式“发布管理员”角色可能降低部署速度。</span><span class="sxs-lookup"><span data-stu-id="81940-143">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span> <span data-ttu-id="81940-144">CI/CD 过程的自动化程度和可靠性越高，对集中授权的需求就越少。</span><span class="sxs-lookup"><span data-stu-id="81940-144">The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="81940-145">也就是说，可以对主要功能更新与次要 bug 修复的发布采用不同的策略。</span><span class="sxs-lookup"><span data-stu-id="81940-145">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="81940-146">分散化并不意味着无需任何监管。</span><span class="sxs-lookup"><span data-stu-id="81940-146">Being decentralized does not mean there should be zero governance.</span></span>

- <span data-ttu-id="81940-147">**容器映像版本控制**。</span><span class="sxs-lookup"><span data-stu-id="81940-147">**Container image versioning**.</span></span> <span data-ttu-id="81940-148">在开发和测试周期，CI/CD 过程将生成许多容器映像。</span><span class="sxs-lookup"><span data-stu-id="81940-148">During the development and test cycle, the CI/CD process will build many container images.</span></span> <span data-ttu-id="81940-149">其中只有一部分映像是发布候选项，因此，也只有这一部分发布候选项会推送到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="81940-149">Only some of those are candidates for release, and then only some of those release candidates will get pushed into production.</span></span> <span data-ttu-id="81940-150">应该制定明确的版本控制策略，以便知道目前已有哪些映像部署到了生产环境，并可以根据需要回滚到以前的版本。</span><span class="sxs-lookup"><span data-stu-id="81940-150">You should have a clear versioning strategy, so that you know which images are currently deployed to production, and can roll back to a previous version if necessary.</span></span> 

- <span data-ttu-id="81940-151">**服务更新**。</span><span class="sxs-lookup"><span data-stu-id="81940-151">**Service updates**.</span></span> <span data-ttu-id="81940-152">将某个服务更新到新版本时，更新过程不应中断依赖于该服务的其他服务。</span><span class="sxs-lookup"><span data-stu-id="81940-152">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span> <span data-ttu-id="81940-153">如果执行滚动更新，在某段时间内，将有多个版本运行。</span><span class="sxs-lookup"><span data-stu-id="81940-153">If you do a rolling update, there will be a period of time when a mix of versions is running.</span></span> 
 
<span data-ttu-id="81940-154">这些难题反映了一个基本矛盾。</span><span class="sxs-lookup"><span data-stu-id="81940-154">These challenges reflect a fundamental tension.</span></span> <span data-ttu-id="81940-155">一方面，团队要尽量独立地工作。</span><span class="sxs-lookup"><span data-stu-id="81940-155">On the one hand, teams need to work as independently as possible.</span></span> <span data-ttu-id="81940-156">另一方面，需要进行某种协调，只让一个人运行集成测试、将整个解决方案重新部署到新群集、回滚错误更新或执行其他任务。</span><span class="sxs-lookup"><span data-stu-id="81940-156">On the other hand, some coordination is needed so that a single person can do tasks like running an integration test, redeploying the entire solution to a new cluster, or rolling back a bad update.</span></span> 
 
## <a name="cicd-approaches-for-microservices"></a><span data-ttu-id="81940-157">微服务的 CI/CD 方法</span><span class="sxs-lookup"><span data-stu-id="81940-157">CI/CD approaches for microservices</span></span>

<span data-ttu-id="81940-158">对于每个服务团队而言，一种合理的做法是将其生成环境容器化。</span><span class="sxs-lookup"><span data-stu-id="81940-158">It's a good practice for every service team to containerize their build environment.</span></span> <span data-ttu-id="81940-159">此容器应该包含生成服务代码项目所需的全部生成工具。</span><span class="sxs-lookup"><span data-stu-id="81940-159">This container should have all of the build tools necessary to build the code artifacts for their service.</span></span> <span data-ttu-id="81940-160">通常，可以找到适用于所用语言和框架的正式 Docker 映像。</span><span class="sxs-lookup"><span data-stu-id="81940-160">Often you can find an official Docker image for your language and framework.</span></span> <span data-ttu-id="81940-161">然后，可以使用 `docker run` 或 Docker Compose 来运行生成。</span><span class="sxs-lookup"><span data-stu-id="81940-161">Then you can use `docker run` or Docker Compose to run the build.</span></span> 

<span data-ttu-id="81940-162">使用此方法可以方便地设置新的生成环境。</span><span class="sxs-lookup"><span data-stu-id="81940-162">With this approach, it's trivial to set up a new build environment.</span></span> <span data-ttu-id="81940-163">想要生成代码的开发人员不需要安装一套生成工具，而只需运行容器映像。</span><span class="sxs-lookup"><span data-stu-id="81940-163">A developer who wants to build your code doesn't need to install a set of build tools, but simply runs the container image.</span></span> <span data-ttu-id="81940-164">更重要的是，也许可将生成服务器配置为执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="81940-164">Perhaps more importantly, your build server can be configured to do the same thing.</span></span> <span data-ttu-id="81940-165">这样，就不需要在生成服务器上安装这些工具，或管理有冲突的工具版本。</span><span class="sxs-lookup"><span data-stu-id="81940-165">That way, you don't need to install those tools onto the build server, or manage conflicting versions of tools.</span></span> 

<span data-ttu-id="81940-166">对于本地开发和测试，可以使用 Docker 来运行容器中的服务。</span><span class="sxs-lookup"><span data-stu-id="81940-166">For local development and testing, use Docker to run the service inside a container.</span></span> <span data-ttu-id="81940-167">在运行此过程期间，可能需要运行其他容器来模拟用于本地测试的服务或测试数据库。</span><span class="sxs-lookup"><span data-stu-id="81940-167">As part of this process, you may need to run other containers that have mock services or test databases needed for local testing.</span></span> <span data-ttu-id="81940-168">可以使用 Docker Compose 来协调这些容器，或使用 Minikube 在本地运行 Kubernetes。</span><span class="sxs-lookup"><span data-stu-id="81940-168">You could use Docker Compose to coordinate these containers, or use Minikube to run Kubernetes locally.</span></span> 

<span data-ttu-id="81940-169">准备好代码后，可发出提取请求并合并到主节点中。</span><span class="sxs-lookup"><span data-stu-id="81940-169">When the code is ready, open a pull request and merge into master.</span></span> <span data-ttu-id="81940-170">这样就会在生成服务器上启动一个作业：</span><span class="sxs-lookup"><span data-stu-id="81940-170">This will start a job on the build server:</span></span>

1. <span data-ttu-id="81940-171">生成代码资产。</span><span class="sxs-lookup"><span data-stu-id="81940-171">Build the code assets.</span></span> 
2. <span data-ttu-id="81940-172">针对代码运行单元测试。</span><span class="sxs-lookup"><span data-stu-id="81940-172">Run unit tests against the code.</span></span>
3. <span data-ttu-id="81940-173">生成容器映像。</span><span class="sxs-lookup"><span data-stu-id="81940-173">Build the container image.</span></span>
4. <span data-ttu-id="81940-174">针对正在运行的容器运行功能测试，以测试容器映像。</span><span class="sxs-lookup"><span data-stu-id="81940-174">Test the container image by running functional tests on a running container.</span></span> <span data-ttu-id="81940-175">此步骤可以捕获 Docker 文件中的错误，例如错误的入口点。</span><span class="sxs-lookup"><span data-stu-id="81940-175">This step can catch errors in the Docker file, such as a bad entry point.</span></span>
5. <span data-ttu-id="81940-176">将映像推送到容器注册表。</span><span class="sxs-lookup"><span data-stu-id="81940-176">Push the image to a container registry.</span></span>
6. <span data-ttu-id="81940-177">使用新映像更新测试群集以运行集成测试。</span><span class="sxs-lookup"><span data-stu-id="81940-177">Update the test cluster with the new image to run integration tests.</span></span>

<span data-ttu-id="81940-178">准备好将映像部署到生产环境之后，请更新所需的部署文件来指定最新映像，包括任何 Kubernetes 配置文件。</span><span class="sxs-lookup"><span data-stu-id="81940-178">When the image is ready to go into production, update the deployment files as needed to specify the latest image, including any Kubernetes configuration files.</span></span> <span data-ttu-id="81940-179">然后，将更新应用到生产群集。</span><span class="sxs-lookup"><span data-stu-id="81940-179">Then apply the update to the production cluster.</span></span>

<span data-ttu-id="81940-180">下面是有关提高部署可靠性的一些建议：</span><span class="sxs-lookup"><span data-stu-id="81940-180">Here are some recommendations for making deployments more reliable:</span></span>
 
- <span data-ttu-id="81940-181">针对要部署到群集中的资源（pod、服务等），定义组织范围的容器标记约定、版本控制和命名约定。</span><span class="sxs-lookup"><span data-stu-id="81940-181">Define organization-wide conventions for container tags, versioning, and naming conventions for resources deployed to the cluster (pods, services, and so on).</span></span> <span data-ttu-id="81940-182">这样，便可以更轻松地诊断部署问题。</span><span class="sxs-lookup"><span data-stu-id="81940-182">That can make it easier to diagnose deployment issues.</span></span> 

- <span data-ttu-id="81940-183">创建两个不同的容器注册表，一个用于开发/测试，另一个用于生产。</span><span class="sxs-lookup"><span data-stu-id="81940-183">Create two separate container registries, one for development/testing and one for production.</span></span> <span data-ttu-id="81940-184">只有在已准备好将某个映像部署到生产环境之后，才将它推送到生产注册表。</span><span class="sxs-lookup"><span data-stu-id="81940-184">Don't push an image to the production registry until you're ready to deploy it into production.</span></span> <span data-ttu-id="81940-185">如果将这种做法与容器映像的语义版本控制结合使用，则可以减少意外部署尚未批准发布的版本的可能性。</span><span class="sxs-lookup"><span data-stu-id="81940-185">If you combine this practice with semantic versioning of container images, it can reduce the chance of accidentally deploying a version that wasn't approved for release.</span></span>

## <a name="updating-services"></a><span data-ttu-id="81940-186">更新服务</span><span class="sxs-lookup"><span data-stu-id="81940-186">Updating services</span></span>

<span data-ttu-id="81940-187">可通过多种策略来更新已部署到生产环境的服务。</span><span class="sxs-lookup"><span data-stu-id="81940-187">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="81940-188">下面介绍三个常用选项：滚动更新、蓝绿部署和 Canary 发布。</span><span class="sxs-lookup"><span data-stu-id="81940-188">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-update"></a><span data-ttu-id="81940-189">滚动更新</span><span class="sxs-lookup"><span data-stu-id="81940-189">Rolling update</span></span> 

<span data-ttu-id="81940-190">在滚动更新中部署服务的新实例，然后，新实例可开始立即接收请求。</span><span class="sxs-lookup"><span data-stu-id="81940-190">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="81940-191">启动新实例后，以前的实例将被删除。</span><span class="sxs-lookup"><span data-stu-id="81940-191">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="81940-192">更新部署的 pod 规范时，滚动更新是 Kubernetes 中的默认行为。</span><span class="sxs-lookup"><span data-stu-id="81940-192">Rolling updates are the default behavior in Kubernetes when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="81940-193">部署控制器为更新的 pod 创建新的副本集。</span><span class="sxs-lookup"><span data-stu-id="81940-193">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="81940-194">然后，它会纵向扩展新的副本集并纵向缩减旧的副本集，以保持所需的副本计数。</span><span class="sxs-lookup"><span data-stu-id="81940-194">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="81940-195">在新 pod 准备就绪之前，它不会删除旧 pod。</span><span class="sxs-lookup"><span data-stu-id="81940-195">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="81940-196">Kubernetes 保留更新历史记录，因此，你可以根据需要使用 kubectl 回滚更新。</span><span class="sxs-lookup"><span data-stu-id="81940-196">Kubernetes keeps a history of the update, so you can use kubectl to roll back an update if needed.</span></span> 

<span data-ttu-id="81940-197">如果服务要执行较长的启动任务，则你可以定义就绪状态探测。</span><span class="sxs-lookup"><span data-stu-id="81940-197">If your service performs a long startup task, you can define a readiness probe.</span></span> <span data-ttu-id="81940-198">当容器已准备好开始接收流量时，就绪状态探测会发出报告。</span><span class="sxs-lookup"><span data-stu-id="81940-198">The readiness probe reports when the container is ready to start receiving traffic.</span></span> <span data-ttu-id="81940-199">在探测报告成功之前，Kubernetes 不会将流量发送到 pod。</span><span class="sxs-lookup"><span data-stu-id="81940-199">Kubernetes won't send traffic to the pod until the probe reports success.</span></span> 

<span data-ttu-id="81940-200">滚动更新的一个难题在于，在更新过程中，旧版本和新版本将混合运行并接收流量。</span><span class="sxs-lookup"><span data-stu-id="81940-200">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="81940-201">在此期间，任何请求都可能路由到两个版本中的一个。</span><span class="sxs-lookup"><span data-stu-id="81940-201">During this period, any request could get routed to either of the two versions.</span></span> <span data-ttu-id="81940-202">根据两个版本之间的更改范围，这有可能会造成问题。</span><span class="sxs-lookup"><span data-stu-id="81940-202">That may or may not cause problems, depending on the scope of the changes between the two versions.</span></span> 

### <a name="blue-green-deployment"></a><span data-ttu-id="81940-203">蓝绿部署</span><span class="sxs-lookup"><span data-stu-id="81940-203">Blue-green deployment</span></span>

<span data-ttu-id="81940-204">在蓝绿部署中，需要连同以前的版本一起部署新版本。</span><span class="sxs-lookup"><span data-stu-id="81940-204">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="81940-205">验证新版本之后，可以一次性地将所有流量从以前的版本切换到新版本。</span><span class="sxs-lookup"><span data-stu-id="81940-205">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="81940-206">切换后，可以监视应用程序中的任何问题。</span><span class="sxs-lookup"><span data-stu-id="81940-206">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="81940-207">如果出现问题，可以切换回到旧版本。</span><span class="sxs-lookup"><span data-stu-id="81940-207">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="81940-208">如果没有任何问题，则可以删除旧版本。</span><span class="sxs-lookup"><span data-stu-id="81940-208">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="81940-209">对于较传统的整体或 N 层应用程序而言，蓝绿部署通常要预配两个相同的环境。</span><span class="sxs-lookup"><span data-stu-id="81940-209">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="81940-210">需将新版本部署到过渡环境，然后将客户端流量重定向到过渡环境 &mdash; 例如，通过交换 VIP 地址。</span><span class="sxs-lookup"><span data-stu-id="81940-210">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span>

<span data-ttu-id="81940-211">在 Kubernetes 中，不需要预配单独的群集即可执行蓝绿部署。</span><span class="sxs-lookup"><span data-stu-id="81940-211">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="81940-212">可以利用选择器。</span><span class="sxs-lookup"><span data-stu-id="81940-212">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="81940-213">使用新的 pod 规范和一组不同的标签创建新的部署资源。</span><span class="sxs-lookup"><span data-stu-id="81940-213">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="81940-214">无需删除以前的部署或修改指向该部署的服务，即可创建此部署。</span><span class="sxs-lookup"><span data-stu-id="81940-214">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="81940-215">运行新 pod 后，可以更新服务的选择器，以匹配新部署。</span><span class="sxs-lookup"><span data-stu-id="81940-215">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span> 

<span data-ttu-id="81940-216">蓝绿部署的优势之一是服务可以同时切换所有 pod。</span><span class="sxs-lookup"><span data-stu-id="81940-216">An advantage of blue-green deployments is that the service switches all the pods at the same time.</span></span> <span data-ttu-id="81940-217">更新服务后，所有新请求将路由到新版本。</span><span class="sxs-lookup"><span data-stu-id="81940-217">After the service is updated, all new requests get routed to the new version.</span></span> <span data-ttu-id="81940-218">缺点是，在更新过程中，需要对服务运行 pod 两次（当前 pod 和下一个 pod）。</span><span class="sxs-lookup"><span data-stu-id="81940-218">One drawback is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="81940-219">如果 pod 需要大量的 CPU 或内存资源，则可能需要暂时横向扩展群集以处理资源消耗。</span><span class="sxs-lookup"><span data-stu-id="81940-219">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span> 

### <a name="canary-release"></a><span data-ttu-id="81940-220">Canary 发布</span><span class="sxs-lookup"><span data-stu-id="81940-220">Canary release</span></span>

<span data-ttu-id="81940-221">在 Canary 发布中，可将更新的版本推出到少量的客户端。</span><span class="sxs-lookup"><span data-stu-id="81940-221">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="81940-222">然后，可以监视新服务的行为，再将它推出到所有客户端。</span><span class="sxs-lookup"><span data-stu-id="81940-222">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="81940-223">这样，便可以通过受控的方式慢速推出，观察真实数据并发现问题，避免对所有客户造成影响。</span><span class="sxs-lookup"><span data-stu-id="81940-223">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="81940-224">Canary 发布比蓝绿部署或滚动更新更难于管理，因为必须动态将请求路由到服务的不同版本。</span><span class="sxs-lookup"><span data-stu-id="81940-224">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span> <span data-ttu-id="81940-225">在 Kubernetes 中，可将服务配置为跨越两个副本集（每个版本各有一个），并手动调整副本计数。</span><span class="sxs-lookup"><span data-stu-id="81940-225">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="81940-226">但是，由于 Kubernetes 跨 pod 进行负载均衡的方式，这种方法不够精确。</span><span class="sxs-lookup"><span data-stu-id="81940-226">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="81940-227">例如，如果总共有 10 个副本，则只能以 10% 的增量切换流量。</span><span class="sxs-lookup"><span data-stu-id="81940-227">For example, if you have a total of ten replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="81940-228">如果使用服务网格，则可以使用服务网格路由规则来实现更复杂的 Canary 发布策略。</span><span class="sxs-lookup"><span data-stu-id="81940-228">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span> <span data-ttu-id="81940-229">下面是一些有用的资源：</span><span class="sxs-lookup"><span data-stu-id="81940-229">Here are some resources that may be helpful:</span></span>

- <span data-ttu-id="81940-230">不使用服务网格的 Kubernetes：[Canary 部署](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span><span class="sxs-lookup"><span data-stu-id="81940-230">Kubernetes without service mesh: [Canary deployments](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span></span>
- <span data-ttu-id="81940-231">Linkerd：[动态请求路由](https://linkerd.io/features/routing/)</span><span class="sxs-lookup"><span data-stu-id="81940-231">Linkerd: [Dynamic request routing](https://linkerd.io/features/routing/)</span></span>
- <span data-ttu-id="81940-232">Istio：[使用 Istio 的 Canary 部署](https://istio.io/blog/canary-deployments-using-istio.html)</span><span class="sxs-lookup"><span data-stu-id="81940-232">Istio: [Canary Deployments using Istio](https://istio.io/blog/canary-deployments-using-istio.html)</span></span>

## <a name="conclusion"></a><span data-ttu-id="81940-233">结束语</span><span class="sxs-lookup"><span data-stu-id="81940-233">Conclusion</span></span>

<span data-ttu-id="81940-234">最近几年，本行业已发生巨变，构建记录系统的做法正逐步转变为构建参与系统。</span><span class="sxs-lookup"><span data-stu-id="81940-234">In recent years, there has been a sea change in the industry, a movement from building *systems of record* to building *systems of engagement*.</span></span>

<span data-ttu-id="81940-235">记录系统属于传统的后端办公数据管理应用程序。</span><span class="sxs-lookup"><span data-stu-id="81940-235">Systems of record are traditional back-office data management applications.</span></span> <span data-ttu-id="81940-236">这些系统的核心通常有一个 RDBMS，即单一事实来源。</span><span class="sxs-lookup"><span data-stu-id="81940-236">At the heart of these systems there often sits an RDBMS that is the single source of truth.</span></span> <span data-ttu-id="81940-237">“参与系统”一词是 Geoffrey Moore 在其 2011 年撰写的论文 *Systems of Engagement and the Future of Enterprise IT*（参与系统和企业 IT 的远景）中创造的。</span><span class="sxs-lookup"><span data-stu-id="81940-237">The term "system of engagement" is credited to Geoffrey Moore, in his 2011 paper *Systems of Engagement and the Future of Enterprise IT*.</span></span> <span data-ttu-id="81940-238">参与系统是注重于通信和协作的应用程序。</span><span class="sxs-lookup"><span data-stu-id="81940-238">Systems of engagement are applications focused on communication and collaboration.</span></span> <span data-ttu-id="81940-239">它们能够实时将用户联系到一起。</span><span class="sxs-lookup"><span data-stu-id="81940-239">They connect people in real time.</span></span> <span data-ttu-id="81940-240">此类应用程序必须全天候可用。</span><span class="sxs-lookup"><span data-stu-id="81940-240">They must be available 24/7.</span></span> <span data-ttu-id="81940-241">无需使应用程序脱机，即可定期引入新功能。</span><span class="sxs-lookup"><span data-stu-id="81940-241">New features are introduced regularly without taking the application offline.</span></span> <span data-ttu-id="81940-242">用户的期望比较高，他们不太能够忍受意外的延迟或停机。</span><span class="sxs-lookup"><span data-stu-id="81940-242">Users expect more and are less patient of unexpected delays or downtime.</span></span>

<span data-ttu-id="81940-243">在消费型领域，更好的用户体验可能意味着可衡量的业务价值。</span><span class="sxs-lookup"><span data-stu-id="81940-243">In the consumer space, a better user experience can have measurable business value.</span></span> <span data-ttu-id="81940-244">用户参与应用程序的时间可直接转化为收入。</span><span class="sxs-lookup"><span data-stu-id="81940-244">The amount of time that a user engages with an application may translate directly into revenue.</span></span> <span data-ttu-id="81940-245">在业务系统领域，用户的期望已发生变化。</span><span class="sxs-lookup"><span data-stu-id="81940-245">And in the realm of business systems, users' expectations have changed.</span></span> <span data-ttu-id="81940-246">如果这些系统旨在培养沟通和协作，则必须从面向消费者的应用程序获得提示。</span><span class="sxs-lookup"><span data-stu-id="81940-246">If these systems aim to foster communication and collaboration, they must take their cue from consumer-facing applications.</span></span>

<span data-ttu-id="81940-247">微服务就是对这种不断变化的格局做出的响应。</span><span class="sxs-lookup"><span data-stu-id="81940-247">Microservices are a response to this changing landscape.</span></span> <span data-ttu-id="81940-248">通过将整体应用程序分解为一组松散耦合的服务，我们可以控制每个服务的发布周期，并在不造成停机或重大更改的情况下频繁进行更新。</span><span class="sxs-lookup"><span data-stu-id="81940-248">By decomposing a monolithic application into a group of loosely coupled services, we can control the release cycle of each service, and enable frequent updates without downtime or breaking changes.</span></span> <span data-ttu-id="81940-249">微服务还有助于提高可伸缩性、故障隔离性和复原能力。</span><span class="sxs-lookup"><span data-stu-id="81940-249">Microservices also help with scalability, failure isolation, and resiliency.</span></span> <span data-ttu-id="81940-250">同时，使用云平台可以更轻松地构建和运行微服务，自动预配计算资源、服务形式的容器业务流程协调程序，以及事件驱动的无服务器环境。</span><span class="sxs-lookup"><span data-stu-id="81940-250">Meanwhile, cloud platforms are making it easier to build and run microservices, with automated provisioning of compute resources, container orchestrators as a service, and event-driven serverless environments.</span></span>

<span data-ttu-id="81940-251">但是，如我们所见，微服务体系结构也存在众多难题。</span><span class="sxs-lookup"><span data-stu-id="81940-251">But as we've seen, microservices architectures also being a lot of challenges.</span></span> <span data-ttu-id="81940-252">若要获得成功，必须从坚实的设计开始。</span><span class="sxs-lookup"><span data-stu-id="81940-252">To succeed, you must start from a solid design.</span></span> <span data-ttu-id="81940-253">必须慎重考虑如何分析域、选择技术、为数据建模、设计 API，以及营造成熟的 DevOps 文化。</span><span class="sxs-lookup"><span data-stu-id="81940-253">You must put careful thought into analyzing the domain, choosing technologies, modeling data, designing APIs, and building a mature DevOps culture.</span></span> <span data-ttu-id="81940-254">我们希望本指南和随附的[参考实现](https://github.com/mspnp/microservices-reference-implementation)能够为微服务的设计之旅带来启示。</span><span class="sxs-lookup"><span data-stu-id="81940-254">We hope that this guide, and the accompanying [reference implementation](https://github.com/mspnp/microservices-reference-implementation), has helped to illuminate the journey.</span></span> 

