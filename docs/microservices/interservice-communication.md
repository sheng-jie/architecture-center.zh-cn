---
title: 微服务中的服务间通信
description: 微服务中的服务间通信
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: aff2fb7b2be25ca32d6224cee15363880cfb1488
ms.sourcegitcommit: a8453c4bc7c870fa1a12bb3c02e3b310db87530c
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/29/2017
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="6af8f-103">设计微服务：服务间通信</span><span class="sxs-lookup"><span data-stu-id="6af8f-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="6af8f-104">微服务之间的通信必须高效可靠。</span><span class="sxs-lookup"><span data-stu-id="6af8f-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="6af8f-105">当有大量小型服务交互以完成单个事务时，可能会造成难题。</span><span class="sxs-lookup"><span data-stu-id="6af8f-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="6af8f-106">本章探讨异步消息传递与同步 API 之间的利弊。</span><span class="sxs-lookup"><span data-stu-id="6af8f-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="6af8f-107">然后，探讨设计弹性服务间通信时存在的难题，以及服务网格可以发挥的作用。</span><span class="sxs-lookup"><span data-stu-id="6af8f-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="6af8f-108">挑战</span><span class="sxs-lookup"><span data-stu-id="6af8f-108">Challenges</span></span> 

<span data-ttu-id="6af8f-109">下面是服务间通信存在的主要难题。</span><span class="sxs-lookup"><span data-stu-id="6af8f-109">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="6af8f-110">本章稍后介绍的服务网格旨在应对其中的许多难题。</span><span class="sxs-lookup"><span data-stu-id="6af8f-110">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="6af8f-111">**复原能力**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-111">**Resiliency.**</span></span> <span data-ttu-id="6af8f-112">任意给定的微服务可能有数十甚至数百个实例。</span><span class="sxs-lookup"><span data-stu-id="6af8f-112">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="6af8f-113">某个实例可能出于若干原因而发生故障。</span><span class="sxs-lookup"><span data-stu-id="6af8f-113">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="6af8f-114">可能出现节点级的故障，例如硬件故障或 VM 重新启动。</span><span class="sxs-lookup"><span data-stu-id="6af8f-114">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="6af8f-115">实例可能崩溃或收到不堪重负的请求，因此无法处理任何新请求。</span><span class="sxs-lookup"><span data-stu-id="6af8f-115">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="6af8f-116">其中的任何事件都可能导致网络调用失败。</span><span class="sxs-lookup"><span data-stu-id="6af8f-116">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="6af8f-117">可以借助两种设计模式，以更具弹性的方式发出服务间的网络调用：</span><span class="sxs-lookup"><span data-stu-id="6af8f-117">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="6af8f-118">**[重试](../patterns/retry.md)**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-118">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="6af8f-119">网络调用可能出于暂时性故障（可自行消失）而失败。</span><span class="sxs-lookup"><span data-stu-id="6af8f-119">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="6af8f-120">调用方不会彻底失败，而通常会重试操作特定的次数，或者重试到配置的超时期限结束为止。</span><span class="sxs-lookup"><span data-stu-id="6af8f-120">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="6af8f-121">但是，如果操作不是幂等的，则重试可能导致意外的副作用。</span><span class="sxs-lookup"><span data-stu-id="6af8f-121">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="6af8f-122">原始调用可能成功，但调用方永远不会获得响应。</span><span class="sxs-lookup"><span data-stu-id="6af8f-122">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="6af8f-123">如果调用方重试，则可以调用操作两次。</span><span class="sxs-lookup"><span data-stu-id="6af8f-123">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="6af8f-124">一般而言，重试 POST 或 PATCH 方法并不安全，因为不保证这些方法是幂等的。</span><span class="sxs-lookup"><span data-stu-id="6af8f-124">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="6af8f-125">**[断路器](../patterns/circuit-breaker.md)**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-125">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="6af8f-126">如果失败的请求过多，可能会导致出现瓶颈，因为挂起的请求会在队列中累积。</span><span class="sxs-lookup"><span data-stu-id="6af8f-126">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="6af8f-127">这些被阻止的请求可能占用关键的系统资源，例如内存、线程、数据库连接等，从而导致连发故障。</span><span class="sxs-lookup"><span data-stu-id="6af8f-127">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="6af8f-128">断路器模式可以防止服务重复尝试执行很可能失败的操作。</span><span class="sxs-lookup"><span data-stu-id="6af8f-128">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span> 

<span data-ttu-id="6af8f-129">**负载均衡**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-129">**Load balancing**.</span></span> <span data-ttu-id="6af8f-130">当服务“A”调用服务“B”时，请求必须访问服务“B”的运行中实例。</span><span class="sxs-lookup"><span data-stu-id="6af8f-130">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="6af8f-131">在 Kubernetes 中，`Service` 资源类型为一组 pod 提供稳定的 IP 地址。</span><span class="sxs-lookup"><span data-stu-id="6af8f-131">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="6af8f-132">发往服务 IP 地址的网络流量将通过 iptable 规则转发到 pod。</span><span class="sxs-lookup"><span data-stu-id="6af8f-132">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="6af8f-133">默认情况下，会选择随机 pod。</span><span class="sxs-lookup"><span data-stu-id="6af8f-133">By default, a random pod is chosen.</span></span> <span data-ttu-id="6af8f-134">服务网格（请参阅下文）可以根据观测到的延迟或其他指标提供更智能化的负载均衡算法。</span><span class="sxs-lookup"><span data-stu-id="6af8f-134">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="6af8f-135">**分布式跟踪**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-135">**Distributed tracing**.</span></span> <span data-ttu-id="6af8f-136">单个事务可能跨越多个服务。</span><span class="sxs-lookup"><span data-stu-id="6af8f-136">A single transaction may span multiple services.</span></span> <span data-ttu-id="6af8f-137">因此，可能很难监视系统的整体性能和运行状况。</span><span class="sxs-lookup"><span data-stu-id="6af8f-137">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="6af8f-138">即使每个服务都生成日志和指标，但如果不通过某种方法将这些信息关联在一起，则它们的作用有限。</span><span class="sxs-lookup"><span data-stu-id="6af8f-138">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="6af8f-139">[日志记录和监视](./logging-monitoring.md)一章详细介绍了分布式跟踪，但本章会将此方法作为一个难点来讨论。</span><span class="sxs-lookup"><span data-stu-id="6af8f-139">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="6af8f-140">**服务版本控制**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-140">**Service versioning**.</span></span> <span data-ttu-id="6af8f-141">当团队部署某个服务的新版本时，必须避免中断其他任何服务或依赖于该服务的外部客户端。</span><span class="sxs-lookup"><span data-stu-id="6af8f-141">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="6af8f-142">此外，我们可能需要同时运行某个服务的多个版本，并将请求路由到特定的版本。</span><span class="sxs-lookup"><span data-stu-id="6af8f-142">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="6af8f-143">有关此问题的详细讨论，请参阅 [API 版本控制](./api-design.md#api-versioning)。</span><span class="sxs-lookup"><span data-stu-id="6af8f-143">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="6af8f-144">**TLS 加密和相互 TLS 身份验证**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-144">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="6af8f-145">出于安全原因，我们可能需要使用 TLS 加密服务之间的流量，并使用相互 TLS 身份验证对调用方进行身份验证。</span><span class="sxs-lookup"><span data-stu-id="6af8f-145">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="6af8f-146">同步与异步消息传递</span><span class="sxs-lookup"><span data-stu-id="6af8f-146">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="6af8f-147">微服务可以使用两种基本消息传递模式来与其他微服务通信。</span><span class="sxs-lookup"><span data-stu-id="6af8f-147">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span> 

1. <span data-ttu-id="6af8f-148">同步通信。</span><span class="sxs-lookup"><span data-stu-id="6af8f-148">Synchronous communication.</span></span> <span data-ttu-id="6af8f-149">在此模式下，一个服务使用 HTTP 或 gRPC 等协议调用另一个服务公开的 API。</span><span class="sxs-lookup"><span data-stu-id="6af8f-149">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="6af8f-150">此选项之所以称作同步消息传递模式，是因为调用方需要等待接收方返回的响应。</span><span class="sxs-lookup"><span data-stu-id="6af8f-150">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span> 

2. <span data-ttu-id="6af8f-151">异步消息传递。</span><span class="sxs-lookup"><span data-stu-id="6af8f-151">Asynchronous message passing.</span></span> <span data-ttu-id="6af8f-152">在此模式下，服务可以在不等待回应的情况下发送消息，然后一个或多个服务以异步方式处理该消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-152">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="6af8f-153">必须区分异步 I/O 和异步协议。</span><span class="sxs-lookup"><span data-stu-id="6af8f-153">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="6af8f-154">异步 I/O 表示在完成 I/O 时，调用线程不会阻塞。</span><span class="sxs-lookup"><span data-stu-id="6af8f-154">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="6af8f-155">这对于性能很重要，但在体系结构方面需要规划实施细节。</span><span class="sxs-lookup"><span data-stu-id="6af8f-155">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="6af8f-156">异步协议表示发送方无需等待响应。</span><span class="sxs-lookup"><span data-stu-id="6af8f-156">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="6af8f-157">HTTP 是同步协议，不过，HTTP 客户端在发送请求时可以使用异步 I/O。</span><span class="sxs-lookup"><span data-stu-id="6af8f-157">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span> 

<span data-ttu-id="6af8f-158">每种模式各有利弊。</span><span class="sxs-lookup"><span data-stu-id="6af8f-158">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="6af8f-159">请求/响应是易于理解的范例，因此，设计 API 在感觉上可能比设计消息传递系统更单纯。</span><span class="sxs-lookup"><span data-stu-id="6af8f-159">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="6af8f-160">但是，异步消息传递在微服务体系结构中具有一些有利的优势：</span><span class="sxs-lookup"><span data-stu-id="6af8f-160">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="6af8f-161">**减少耦合**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-161">**Reduced coupling**.</span></span> <span data-ttu-id="6af8f-162">消息发送方不需要了解使用者。</span><span class="sxs-lookup"><span data-stu-id="6af8f-162">The message sender does not need to know about the consumer.</span></span> 

- <span data-ttu-id="6af8f-163">**多个订阅方**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-163">**Multiple subscribers**.</span></span> <span data-ttu-id="6af8f-164">使用发布/订阅模型，多个使用者可以订阅事件接收。</span><span class="sxs-lookup"><span data-stu-id="6af8f-164">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="6af8f-165">请参阅[事件驱动的体系结构样式](/azure/architecture/guide/architecture-styles/event-driven)。</span><span class="sxs-lookup"><span data-stu-id="6af8f-165">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="6af8f-166">**故障隔离**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-166">**Failure isolation**.</span></span> <span data-ttu-id="6af8f-167">如果使用者发生故障，发送方仍可发送消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-167">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="6af8f-168">当使用者恢复时，将拾取消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-168">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="6af8f-169">此功能在微服务体系结构中尤其有用，因为每个服务具有自身的生命周期。</span><span class="sxs-lookup"><span data-stu-id="6af8f-169">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="6af8f-170">在任意给定时间，服务可能不可用，或者被新版本取代。</span><span class="sxs-lookup"><span data-stu-id="6af8f-170">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="6af8f-171">异步消息传递可以处理间歇性的停机。</span><span class="sxs-lookup"><span data-stu-id="6af8f-171">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="6af8f-172">另一方面，同步 API 需要下游服务保持可用，否则操作将会失败。</span><span class="sxs-lookup"><span data-stu-id="6af8f-172">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span> 
 
- <span data-ttu-id="6af8f-173">**响应能力**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-173">**Responsiveness**.</span></span> <span data-ttu-id="6af8f-174">上游服务如果不需要等待下游服务完成处理，则可以更快地做出回复。</span><span class="sxs-lookup"><span data-stu-id="6af8f-174">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="6af8f-175">这一点在微服务体系结构中尤其有用。</span><span class="sxs-lookup"><span data-stu-id="6af8f-175">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="6af8f-176">如果存在服务依赖关系链（服务 A 调用 B，后者调用 C，依此类推），则等待同步调用可能会增大不可接受的延迟时间。</span><span class="sxs-lookup"><span data-stu-id="6af8f-176">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="6af8f-177">**负载调节**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-177">**Load leveling**.</span></span> <span data-ttu-id="6af8f-178">队列可以充当缓冲区来调节工作负荷，使接收方可以根据自身的速率处理消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-178">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span> 

- <span data-ttu-id="6af8f-179">**工作流**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-179">**Workflows**.</span></span> <span data-ttu-id="6af8f-180">完成工作流中的每个步骤后，可以通过在消息中设置检查点，使用队列管理该工作流。</span><span class="sxs-lookup"><span data-stu-id="6af8f-180">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="6af8f-181">但是，有效使用异步消息传递也存在一些难题。</span><span class="sxs-lookup"><span data-stu-id="6af8f-181">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="6af8f-182">**与消息传递基础结构耦合**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-182">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="6af8f-183">使用特定的消息传递基础结构可能导致与该基础结构紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="6af8f-183">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="6af8f-184">以后很难切换到另一个消息传递基础结构。</span><span class="sxs-lookup"><span data-stu-id="6af8f-184">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="6af8f-185">**延迟**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-185">**Latency**.</span></span> <span data-ttu-id="6af8f-186">如果消息队列已填满，则操作的端到端延迟可能变得很高。</span><span class="sxs-lookup"><span data-stu-id="6af8f-186">End-to-end latency for an operation may become high if the message queues fill up.</span></span>  

- <span data-ttu-id="6af8f-187">**成本**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-187">**Cost**.</span></span> <span data-ttu-id="6af8f-188">吞吐量较高时，消息传递基础结构的资金成本可能很大。</span><span class="sxs-lookup"><span data-stu-id="6af8f-188">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="6af8f-189">**复杂性**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-189">**Complexity**.</span></span> <span data-ttu-id="6af8f-190">处理异步消息传递并不是一个简单的任务。</span><span class="sxs-lookup"><span data-stu-id="6af8f-190">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="6af8f-191">例如，必须通过消除重复项或使操作成为幂等操作，来处理重复的消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-191">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="6af8f-192">此外，很难使用异步消息传递实现请求-响应语义。</span><span class="sxs-lookup"><span data-stu-id="6af8f-192">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="6af8f-193">若要发送响应，需要使用另一个队列，并通过某种方式来关联请求和响应消息。</span><span class="sxs-lookup"><span data-stu-id="6af8f-193">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="6af8f-194">**吞吐量**。</span><span class="sxs-lookup"><span data-stu-id="6af8f-194">**Throughput**.</span></span> <span data-ttu-id="6af8f-195">如果消息需要队列语义，则队列可能成为系统中的瓶颈。</span><span class="sxs-lookup"><span data-stu-id="6af8f-195">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="6af8f-196">每条消息至少需要一个排队操作和一个取消排队操作。</span><span class="sxs-lookup"><span data-stu-id="6af8f-196">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="6af8f-197">此外，队列语义通常需要在消息传递基础结构中进行某种锁定。</span><span class="sxs-lookup"><span data-stu-id="6af8f-197">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="6af8f-198">如果队列是托管服务，可能会进一步造成延迟，因为队列在群集虚拟网络的外部。</span><span class="sxs-lookup"><span data-stu-id="6af8f-198">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="6af8f-199">可以通过批处理消息来缓解这些问题，但这会增加代码的复杂性。</span><span class="sxs-lookup"><span data-stu-id="6af8f-199">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="6af8f-200">如果消息不需要队列语义，也许可以事件流来取代队列。</span><span class="sxs-lookup"><span data-stu-id="6af8f-200">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="6af8f-201">有关详细信息，请参阅[事件驱动的体系结构样式](../guide/architecture-styles/event-driven.md)。</span><span class="sxs-lookup"><span data-stu-id="6af8f-201">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>  

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="6af8f-202">无人机交付：选择消息传递模式</span><span class="sxs-lookup"><span data-stu-id="6af8f-202">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="6af8f-203">考虑到上述因素，开发团队针对无人机交付应用程序做出了以下设计选择</span><span class="sxs-lookup"><span data-stu-id="6af8f-203">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="6af8f-204">引入服务公开一个公共 REST API，客户端应用程序使用该 API 来安排、更新或取消交付。</span><span class="sxs-lookup"><span data-stu-id="6af8f-204">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="6af8f-205">引入服务使用事件中心将异步消息发送到计划程序服务。</span><span class="sxs-lookup"><span data-stu-id="6af8f-205">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="6af8f-206">必须使用异步消息来实现引入操作所需的负载调节。</span><span class="sxs-lookup"><span data-stu-id="6af8f-206">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="6af8f-207">有关引入服务和计划程序服务交互方式的详细信息，请参阅[引入和工作流][ingestion-workflow]。</span><span class="sxs-lookup"><span data-stu-id="6af8f-207">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="6af8f-208">帐户、交付、包裹、无人机和第三方运输服务全部公开内部 REST API。</span><span class="sxs-lookup"><span data-stu-id="6af8f-208">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="6af8f-209">计划程序服务调用这些 API 来执行用户请求。</span><span class="sxs-lookup"><span data-stu-id="6af8f-209">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="6af8f-210">使用同步 API 的原因之一是计划程序需要从每个下游服务获取响应。</span><span class="sxs-lookup"><span data-stu-id="6af8f-210">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="6af8f-211">任何一个下游服务失败都意味着整个操作失败。</span><span class="sxs-lookup"><span data-stu-id="6af8f-211">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="6af8f-212">但是，一个潜在的问题是调用后端服务造成的延迟量。</span><span class="sxs-lookup"><span data-stu-id="6af8f-212">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span> 

- <span data-ttu-id="6af8f-213">如果任一下游服务出现非暂时性故障，应将整个事务标记为失败。</span><span class="sxs-lookup"><span data-stu-id="6af8f-213">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="6af8f-214">为了应对这种情况，计划程序服务会将异步消息发送给监督程序，使监督程序能够根据[引入和工作流][ingestion-workflow]一章中所述计划补偿事务。</span><span class="sxs-lookup"><span data-stu-id="6af8f-214">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>   

- <span data-ttu-id="6af8f-215">交付服务公开一个公共 API，客户端可使用该 API 获取交付状态。</span><span class="sxs-lookup"><span data-stu-id="6af8f-215">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="6af8f-216">[API 网关](./gateway.md)一章介绍了 API 网关如何在客户端中隐藏基础服务，使客户端不需要知道哪些服务公开了哪些 API。</span><span class="sxs-lookup"><span data-stu-id="6af8f-216">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span> 

- <span data-ttu-id="6af8f-217">当某架无人机已起飞时，无人机服务会发送包含该无人机当前位置和状态的事件。</span><span class="sxs-lookup"><span data-stu-id="6af8f-217">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="6af8f-218">交付服务会侦听这些事件，以跟踪交付状态。</span><span class="sxs-lookup"><span data-stu-id="6af8f-218">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="6af8f-219">当交付状态发生更改时，交付服务会发送交付状态事件，例如 `DeliveryCreated` 或 `DeliveryCompleted`。</span><span class="sxs-lookup"><span data-stu-id="6af8f-219">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="6af8f-220">任何服务都可以订阅这些事件。</span><span class="sxs-lookup"><span data-stu-id="6af8f-220">Any service can subscribe to these events.</span></span> <span data-ttu-id="6af8f-221">在当前设计中，交付服务是唯一的订阅方，但以后可能会推出其他订阅方。</span><span class="sxs-lookup"><span data-stu-id="6af8f-221">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="6af8f-222">例如，事件可能会进入实时分析服务。</span><span class="sxs-lookup"><span data-stu-id="6af8f-222">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="6af8f-223">此外，由于计划程序无需等待响应，添加更多的订阅方并不影响主要工作流路径。</span><span class="sxs-lookup"><span data-stu-id="6af8f-223">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![](./images/drone-communication.png)

<span data-ttu-id="6af8f-224">请注意，交付状态事件派生自无人机位置事件。</span><span class="sxs-lookup"><span data-stu-id="6af8f-224">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="6af8f-225">例如，当无人机抵达交货地点并投递了包裹时，交付服务会将此状态转换为 DeliveryCompleted 事件。</span><span class="sxs-lookup"><span data-stu-id="6af8f-225">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="6af8f-226">这是在域模型方面可以考虑的一个示例。</span><span class="sxs-lookup"><span data-stu-id="6af8f-226">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="6af8f-227">如前所述，无人机管理属于独立的边界上下文。</span><span class="sxs-lookup"><span data-stu-id="6af8f-227">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="6af8f-228">无人机事件传达无人机的物理位置。</span><span class="sxs-lookup"><span data-stu-id="6af8f-228">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="6af8f-229">另一方面，交付事件表示交付状态的更改，属于不同的业务实体。</span><span class="sxs-lookup"><span data-stu-id="6af8f-229">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="6af8f-230">使用服务网格</span><span class="sxs-lookup"><span data-stu-id="6af8f-230">Using a service mesh</span></span>

<span data-ttu-id="6af8f-231">服务网格是处理服务间通信的软件层。</span><span class="sxs-lookup"><span data-stu-id="6af8f-231">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="6af8f-232">服务网格旨在解决上一部分中列出的许多问题，并将这些问题的责任从微服务本身转移到共享层。</span><span class="sxs-lookup"><span data-stu-id="6af8f-232">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="6af8f-233">服务网格充当代理，可截获群集中微服务之间的网络通信。</span><span class="sxs-lookup"><span data-stu-id="6af8f-233">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span> 

> [!NOTE]
> <span data-ttu-id="6af8f-234">服务网格是[代表模式](../patterns/ambassador.md)（代表应用程序发送网络请求的帮助程序服务）的一个例子。</span><span class="sxs-lookup"><span data-stu-id="6af8f-234">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span> 

<span data-ttu-id="6af8f-235">目前，Kubernetes 中服务网格的主要选项包括 [linkerd](https://linkerd.io/) 和 [Istio](https://istio.io/)。</span><span class="sxs-lookup"><span data-stu-id="6af8f-235">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="6af8f-236">这两种技术正在快速演进。</span><span class="sxs-lookup"><span data-stu-id="6af8f-236">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="6af8f-237">在编写本指南时，最新的 Istio 版本为 0.2，因此它仍然是很新的技术。</span><span class="sxs-lookup"><span data-stu-id="6af8f-237">At the time we wrote this guide, the latest Istio release is 0.2, so it is still very new.</span></span> <span data-ttu-id="6af8f-238">但是，linkerd 和 Istio 具有一些共同的功能，包括：</span><span class="sxs-lookup"><span data-stu-id="6af8f-238">However, some features that both linkerd and Istio have in common include:</span></span> 

- <span data-ttu-id="6af8f-239">根据观测到的延迟或未完成的请求数，在会话级别进行负载均衡。</span><span class="sxs-lookup"><span data-stu-id="6af8f-239">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="6af8f-240">这样，便可以基于 Kubernetes 提供的第 4 层负载均衡来提高性能。</span><span class="sxs-lookup"><span data-stu-id="6af8f-240">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span> 

- <span data-ttu-id="6af8f-241">基于 URL 路径、主机标头、API 版本或其他应用程序级规则进行第 7 层路由。</span><span class="sxs-lookup"><span data-stu-id="6af8f-241">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="6af8f-242">失败请求重试。</span><span class="sxs-lookup"><span data-stu-id="6af8f-242">Retry of failed requests.</span></span> <span data-ttu-id="6af8f-243">服务网格可识别 HTTP 错误代码，并可以自动重试失败的请求。</span><span class="sxs-lookup"><span data-stu-id="6af8f-243">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="6af8f-244">可以配置最大重试次数和超时期限，以限制最大延迟。</span><span class="sxs-lookup"><span data-stu-id="6af8f-244">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span> 

- <span data-ttu-id="6af8f-245">断路。</span><span class="sxs-lookup"><span data-stu-id="6af8f-245">Circuit breaking.</span></span> <span data-ttu-id="6af8f-246">如果某个实例一直无法完成请求，则服务网格会暂时性地将它标记为不可用。</span><span class="sxs-lookup"><span data-stu-id="6af8f-246">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="6af8f-247">在回退期过后，服务将重试该实例。</span><span class="sxs-lookup"><span data-stu-id="6af8f-247">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="6af8f-248">可以根据多个条件（例如连续失败次数）来配置断路器。</span><span class="sxs-lookup"><span data-stu-id="6af8f-248">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="6af8f-249">服务网格会捕获有关服务间调用的指标，例如请求量、延迟、错误和成功率，以及响应大小。</span><span class="sxs-lookup"><span data-stu-id="6af8f-249">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="6af8f-250">此外，服务网格可以通过添加请求中每个跃点的关联信息，来启用分布式跟踪。</span><span class="sxs-lookup"><span data-stu-id="6af8f-250">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="6af8f-251">服务间调用的相互 TLS 身份验证。</span><span class="sxs-lookup"><span data-stu-id="6af8f-251">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="6af8f-252">是否需要服务网格？</span><span class="sxs-lookup"><span data-stu-id="6af8f-252">Do you need a service mesh?</span></span> <span data-ttu-id="6af8f-253">显然，服务网格为分布式系统带来的价值很有吸引力。</span><span class="sxs-lookup"><span data-stu-id="6af8f-253">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="6af8f-254">如果不使用服务网格，则需要考虑本章开头所述的难题。</span><span class="sxs-lookup"><span data-stu-id="6af8f-254">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="6af8f-255">不使用服务网格也可以解决重试、断路器和分布式跟踪等方面的问题，但是，服务网格可将这些问题从单个服务转移到专用的层。</span><span class="sxs-lookup"><span data-stu-id="6af8f-255">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="6af8f-256">另一方面，服务网格是相对较新的技术，目前仍需完善。</span><span class="sxs-lookup"><span data-stu-id="6af8f-256">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="6af8f-257">部署服务网格会增大群集设置和配置的复杂性。</span><span class="sxs-lookup"><span data-stu-id="6af8f-257">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="6af8f-258">另外，它可能造成性能影响，因为请求现在是通过服务网格代理路由的，并且附加的服务在群集中的每个节点上运行。</span><span class="sxs-lookup"><span data-stu-id="6af8f-258">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="6af8f-259">在生产环境中部署服务网格之前，应该执行全面的性能和负载测试。</span><span class="sxs-lookup"><span data-stu-id="6af8f-259">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="6af8f-260">API 设计</span><span class="sxs-lookup"><span data-stu-id="6af8f-260">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md
